# 闭包

从技术的角度讲，所有的JavaScript函数都是闭包。

因为闭包的定义就是：**闭包是指那些能够访问自由变量的函数。**

什么是自由变量呢：**自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。(也就是作用域链中该函数执行上下文的活动对象AO之外的作用域中的变量)**

因为无论我们执行任何函数，作用域链中都会包含全局变量对象(GlobalContext.VO)，全局变量就是我们能访问到的自由变量，此时就产生了闭包。

在这里复习一下一个执行上下文（ExecutionContext）都由什么组成：
1. 变量对象(Variable Object，VO)
2. 作用域链(Scope Chain)
3. this (浏览器中全局上下文(GlobalContext)的this即window)

举个例子:
```js
var a = 1;

function foo() {
  console.log(a);
}

foo();
```

foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。所以函数 foo + 自由变量 a 就组成了一个闭包

因为作用域链的存在，即使函数已经执行完毕，执行上下文已经被销毁（即从执行上下文栈中被弹出），但是它的活动对象AO依然保存在了它内部创建的函数的作用域链中，所以调用这个内部函数依然可以访问函数中定义的变量。

此时只要我们把这个内部函数 return 出去并持有对它的引用，那么就可以保持对函数AO的访问

总结一下，我们实践中的闭包应该是如下两种情况：

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回，或者赋值给了外部变量）

2. 在代码中引用了自由变量

**注意：每个闭包保存的AO是相互独立的**

举个例子

```js
function foo() {
  var o = { a: 1 }
  function bar() {
    o.a++
    console.log(o.a)
  }
  return bar
}

var m = foo()
var n = foo()

m() // 2
m() // 3
n() // 4
```

m 和 n 中的 o 就是两个不同的对象