# 作用域与闭包

## 作用域

### 什么是作用域？

作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）的规则，在 JS 引擎中，作用域会在相应的执行上下文中的变量对象(可以看做真正存储变量的地方)中查找变量值。

### 什么是词法作用域？

词法作用域是作用域的一种工作模型，作用域是由书写代码时函数声明的位置来决定

### JS中作用域的种类

1. 全局作用域 Global (用于访问全局执行上下文中的全局变量对象)
2. 顶级作用域 Script  (一块可执行代码段的作用域，const let class 在 Script 中声明的变量不会挂载到 Global 中，而 var function 则会)
3. 函数作用域 Scope  (一个函数内部自己的作用域，用于访问一个函数执行上下文中存储变量的的变量对象)
4. 闭包作用域 Closure  (一个函数执行结束之后，它的 Scope 会被销毁，但是如果有子函数访问了该 Scope 下的某些变量，那么这些变量就会形成一个 Closure 作用域，而不会被 GC 回收)
5. 块级作用域 Block  (ES6 新增的作用域类型，在循环体内或者 if 代码块内会生成)

### 作用域链

函数内部所能访问到的所有作用域组成了作用域链（由内到外）

## 闭包

从技术的角度讲，所有的JavaScript函数都是闭包。

JavaScript是一门词法作用域的语言，而闭包正是词法作用域的提现。

因为闭包的定义就是：**那些能够访问自由变量的函数。**

那什么是自由变量呢：**自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。(也就是作用域链中该函数执行上下文的活动对象AO之外的作用域中的变量)**

因为无论我们执行任何函数，作用域链中都会包含全局作用域 Global，即我们可以访问全局变量对象(GlobalContext.VO)，全局变量就是我们能访问到的自由变量，此时就产生了闭包。

在这里复习一下一个执行上下文（ExecutionContext）都由什么组成：

1. 变量对象(Variable Object，VO)
2. 作用域链(Scopes Chain)
3. this (浏览器中全局上下文(GlobalContext)的this即window)

举个例子:
```js
var a = 1;

function foo() {
  console.log(a);
}

foo();
```

foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。所以函数 foo + 自由变量 a 就组成了一个闭包

因为作用域链的存在，即使外部函数已经执行完毕，外部的 Scope 即使被销毁，但是内部函数依然可以保持对外部 Scope 的访问，因为在确定词法作用域的时候，外部的 scope 已经留有一份在内部函数中(生成了 Closure 作用域)。


总结一下，我们实践中的闭包应该是如下两种情况：

1. 即使创建函数的上下文已经销毁，该函数仍然存在（比如，内部函数从父函数中返回，或者赋值给了外部变量，在其定义环境之外运行）

2. 在函数内代码中引用了自由变量

**注意：每个闭包保存的外部环境变量是相互独立的，因为生成该闭包后父作用域就会被销毁（推出执行栈），生成下个闭包的时候又是全新的作用域（新的执行上下文）**

举个例子

```js
function foo() {
  var o = { a: 1 }
  var i = 1
  function bar() {
    o.a++
    i++
    console.log(o.a, i)
  }
  return bar
}

var m = foo()
var n = foo()

m() // 2 2
m() // 3 3
n() // 2 2
```

m 和 n 中的 o 就是两个不同的对象，i 也是不同的

