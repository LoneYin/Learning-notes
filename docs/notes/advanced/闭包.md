# 闭包

从技术的角度讲，所有的JavaScript函数都是闭包。

JavaScript是一门词法作用域的语言，而闭包正是词法作用域的提现。

因为闭包的定义就是：**那些能够访问自由变量的函数。**

那什么是自由变量呢：**自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。(也就是作用域链中该函数执行上下文的活动对象AO之外的作用域中的变量)**

因为无论我们执行任何函数，作用域链中都会包含全局变量对象(GlobalContext.VO)，全局变量就是我们能访问到的自由变量，此时就产生了闭包。

在这里复习一下一个执行上下文（ExecutionContext）都由什么组成：
1. 变量对象(Variable Object，VO)
2. 作用域链(Scope Chain)
3. this (浏览器中全局上下文(GlobalContext)的this即window)

举个例子:
```js
var a = 1;

function foo() {
  console.log(a);
}

foo();
```

foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。所以函数 foo + 自由变量 a 就组成了一个闭包

因为作用域链的存在，即使外部函数已经执行完毕，外部的 scope 即使被销毁，但是内部函数依然可以保持对外部 scope 的访问，因为在确定词法作用域的时候，外部的 scope 已经留有一份在内部函数中。

此时只要我们把这个内部函数 return 出去并持有对它的引用，那么就可以保持对函数AO的访问（也就是说在函数在其创建环境(scope)之外运行）

总结一下，我们实践中的闭包应该是如下两种情况：

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回，或者赋值给了外部变量）

2. 在代码中引用了自由变量

**注意：每个闭包保存的外部环境变量是相互独立的，因为生成该闭包后父作用域就会被销毁（推出执行栈），生成下个闭包的时候又是全新的作用域（新的执行上下文）**

举个例子

```js
function foo() {
  var o = { a: 1 }
  var i = 1
  function bar() {
    o.a++
    i++
    console.log(o.a, i)
  }
  return bar
}

var m = foo()
var n = foo()

m() // 2 2
m() // 3 3
n() // 2 2
```

m 和 n 中的 o 就是两个不同的对象，i 也是不同的