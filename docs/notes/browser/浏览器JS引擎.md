# 浏览器JS引擎（V8）

## V8的JavaScript执行管道

<img src="/Learning-notes/img/v8.png">

V8 目前形成了由解析器、基线编译器 Ignition 和优化编译器 TurboFan 组成的 JavaScript 执行管道。

解析器 Parser 将 JavaScript 源代码转换成 AST，基线编译器 Ignition 将 AST 编译为字节码，当代码满足一定条件时，将被优化编译器 TurboFan 重新编译生成优化的字节码。

### 解析器与AST

解析代码需要时间，所以 JavaScript 引擎会尽可能避免完全解析源代码文件。另一方面，在一次用户访问中，页面中会有很多代码不会被执行到，比如，通过用户交互行为触发的动作。
正因为如此，所有主流浏览器都实现了惰性解析（Lazy Parsing）。解析器不必为每个函数生成 AST（Abstract Syntax tree，抽象语法树），而是可以决定“预解析”（Pre-parsing）或“完全解析”它所遇到的函数。

预解析会检查源代码的语法并抛出语法错误，但不会解析函数中变量的作用域或生成 AST，只是生成了一个词法作用域。完全解析则将分析函数体并生成源代码对应的 AST 数据结构。相比正常解析，预解析的速度快了 2 倍。

生成 AST 主要经过两个阶段：分词（词法分析）和解析（语法分析）。AST旨在通过一种结构化的树形数据结构来描述源代码的具体语法组成，常用于语法检查（静态代码分析）、代码混淆、代码优化等。
我们可以借助 AST Explorer 工具生成 JavaScript 代码的 AST。

### 基线编译器 Ignition 与字节码

V8 引入 JIT（Just In Time，即时编译）技术，通过 Ignition 基线编译器快速生成字节码进行执行。(值得一提的是，在引入 Ignition 之前，V8 的 Full-Codegen 编译器 是跳过 AST 编译到字节码这一步的，V8 会将 AST 直接生成机器码，但是这样会使得内存负担加重，这也是Chrome之前为人诟病的一点)

直接生成机器码固然可以加快执行速度，但是耗费的内存空间会变大，所以V8在一开始只编译最外层代码，不能一次性编译全部的代码，而且一些只运行一次的代码会常驻，浪费了宝贵的内存资源。而引入字节码后缓存的是更紧凑的字节码，这样虽然牺牲了一点执行效率，但是既加快了启动速度，又减少了内存占用，而且跟新的优化编译器 TurboFan 完美配合，简化了架构。

字节码是机器码的抽象。如果字节码的设计与物理 CPU 的计算模型相同，那么将字节码编译成机器代码就会更加容易。这就是为什么解释器通常是寄存器或堆栈机器。Ignition 是一个带有累加器的寄存器。

和之前的基线编译器 Full-Codegen 相比，Ignition 生成的是体积更小的字节码（Full-Codegen 生成的是机器码）。字节码可以直接被优化编译器 TurboFan 用于生成机器码，避免优化编译器在优化代码时需要对 JavaScript 源代码重新进行解析。

### 优化编译器 TurboFan 与优化和去优化

编译器需要考虑的函数输入类型变化越少，生成的代码就越小、越快。

众所周知，JavaScript 是弱类型语言。ECMAScript 标准中有大量的多义性和类型判断，因此通过基线编译器生成的代码执行效率低下。

举个例子，+ 运算符的一个操作数就可能是整数、浮点数、字符串、布尔值以及其它的引用类型，更别提它们之间的各种组合（可以感受一下 ECMAScript 标准中对于 + 的定义）。

```js
function addTwo(a, b) {
  return a + b;
}
addTwo(2, 3);                // 3
addTwo(8.6, 2.2);            // 10.8
addTwo("hello ", "world");   // "hello world"
addTwo("true or ", false);   // "true or false"
// 还有很多组合...
```

但这并不意味着 JavaScript 代码没有办法被优化。对于特定的程序逻辑，其接收的参数往往是类型固定的。正因为如此，V8 引入了类型反馈技术。在进行运算的时候，V8 使用类型反馈对所有参数进行动态检查。通过观察执行情况，V8 的 JIT 会将热点代码的字节码优化为高效的机器码。

简单来说，对于重复执行的代码，如果多次执行都传入类型相同的参数，那么 V8 会假设之后每一次执行的参数类型也是相同的，并对代码进行优化。优化后的代码中会保留基本的类型检查。如果之后的每次执行参数类型未改变，V8 将一直执行优化过的代码。而当之后某一次执行时传入的参数类型发生变化时，V8 将会“撤销”之前的优化操作，这一步称为“去优化”（Deoptimization）

需要注意的是，去优化的开销昂贵，在实际编写函数时要尽量避免触发去优化。

## 垃圾回收

V8 只能使用系统的一部分内存，所以当程序内存占用过高时，会触发 V8 的垃圾回收机制。

### V8 对内存的分配

V8 栈内存不用多说，当执行上下文改变的时候，栈顶的内存会先被回收。

V8 引擎会把内存中的 堆内存 分为两块不同的区域，一块称之为老生代（old generation），另一块是新生代（young generation）。

即使同处 新生代 中的对象中，它们的等级也不同，又进一步分为 初级（nursery）代 等级和 中级（intermediate）代 等级。

在 js 中，当一个对象第一次分配内存时，会被分配到 新生代 中的 初级（nursery）代。

这个对象，如果在第一轮的垃圾回收中幸存下来。那么，我们把它的等级提升到 新生代 中的 中级（intermediate）代。

如果再经过下一次垃圾回收，这个对象幸存下来，这时候我们就会把这个对象，从中级（intermediate）代移动到老生代。

> V8 为什么要这么做呢？

在垃圾回收中有一个重要的概念：“代际假说”（The Generational Hypothesis）。就是说，大部分的 js 对象，都是炮灰，一轮垃圾回收后，基本上都不会幸存，在内存中存在的时间很短。换句话说，从垃圾回收的角度来看，很多对象一经分配内存空间随即就变成了不可访问的，所以对象要么活得很久，要么死的很快。既然，短命的 js 对象，和命久的 js 对象有如此的差距，V8 中就把他们区分开，采用不同的垃圾回收策略。

当 javascript 主线程在正常的执行的时候，占用的内存空间会不断的增长。增长就会触发一个极限，触发极限的时候，垃圾回收就被触发了。对于新生代和老生代， V8 分别有两种垃圾回收器去处理。

### V8中两种垃圾回收器

V8 有两个垃圾回收器，一个是主垃圾回收器（Full Mark-Compact），一个是副垃圾回收器( Scavenge )。这两个垃圾回收器，是相互独立的。

主垃圾回收器主要负责老生区中的垃圾回收（也会负责一部分的新生代heap），副垃圾回收器从新生代中回收垃圾。

#### 副垃圾回收器 回收步骤
1. 打标

    这一步，是为了判断这轮GC中哪些对象需要被回收。

    如何判断呢？就是看这个对象能不能被找到。

    打标首先从根部开始查找，也就是顶层的执行栈、全局的对象开始查找，然后查找对象的引用，然后是对象引用的引用，一层层递归的找。

    如果一个对象可以被访问到，则认为这个对象是活的，不应该被回收；否则，就会被回收。

    接下来，我们开始一轮垃圾回收的过程。

2. 清除 from-space
    
    清空from-space(正在使用中的内存区域)，将没有被清除的对象移动至to-space(暂存区)

    这一步也称为 撤离步骤 evacuation step。撤离到 to-space 中的对象，成功的在第一轮的垃圾回收中活了下来，它们从 初级代 晋升到了 中级代。

3. 更新引用指针

    我们发现，js 中对象的引用指针，还是引用到了旧的from-space 空间上，我们需要更新这些引用到 to-space 空间上。

4. 换位

    接下来，我们把 to-space 和 from-space 交换位置。现在 to-space 成为了下一轮的 from-space，from-space 成为了下一轮的 to-space

5. 开启第二轮垃圾回收

    第一轮垃圾回收之后， js 继续执行，会有一些新分配的 初级代 对象，被推入到了 from-space 空间中，安置在在上一轮幸存的 中级代 对象后面。第二轮垃圾回收的过程，和第一轮类似，就不赘述了。

那么为什么垃圾回收要执行两轮呢？

由于堆内存是连续分配的，一轮清除后零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做内存碎片。但是通过换位的操作，就可以解决内存碎片的问题，方便后续连续空间的分配

现今，V8 在新生代垃圾回收中使用并发清理。

#### 副垃圾回收器小结

- 因为代际假说的理论，只有小部分的 js 对象是会幸存下来的，所以在副垃圾回收器中，只会撤离一小部分的对象，拷贝到to-space的空间中，其他大部分对象都统统销毁。

- from-space 和 to-space 只有一个在用，空间开销很大，典型的用空间换时间。

- 辅助线程 并发的帮助撤离

#### 主垃圾回收器  回收步骤
1. 打标

    同上文副垃圾回收器。（辅助线程并发帮助打标）

2. 清扫

    打标之后，V8 知道有哪些对象是不会被访问到，也就是需要被回收的了。这些被回收的对象所占用的位置，人走茶凉，就空了下来，成为了一个空闲的位置。

    V8 会管理这些空闲的位置，以便下次有新到对象来了，可以把新到对象安置在空间位置中。

    V8 把这些空闲的位置，扫到一张叫 FreeList 的表中来记录，这个过程被称为清扫，清扫的过程可以让一个辅助线程在后台静默的去做掉。

3. 压缩

    如果你了解计算机操作系统，一定了解 碎片 的概念。

    压缩的意思是，我们想把 内存中的数据，挤一挤，靠得紧凑一点，把他们中间的间隙——也就是碎片 ，合并成一个大一些的连续空间。这样下次来一个比较大的对象时，可以有充足的空间来存放。

#### 空闲时间垃圾回收

对于 JavaScript 程序员来说，我们是没有办法直接操作垃圾回收器的。

为了解决这个问题， V8 提出了空闲时间的概念。我们的页面跑在浏览器内，浏览器以每秒60帧的速度去执行一些动画，浏览器大约有16.6毫秒的时间去渲染动画的每一帧。

如果这些渲染的工作，提前完成了，那么浏览器在下一帧之前的空闲时间去触发垃圾回收器。

