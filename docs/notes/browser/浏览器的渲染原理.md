# 浏览器的渲染原理

## 浏览器的渲染流程

1. 构建DOM树
   
    浏览器主进程将 html 传给渲染进程，渲染进程会解析文本字符串为树形结构的 DOM 树。一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候。渲染 html 为 DOM 的方法由 HTML Standard 定义。
  
2. 构建渲染树
   
    CSS文件加载完毕，浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树（RenderObject Tree）。

3. 布局（Layout)

    浏览器根据渲染树所体现的节点、各个节点的CSS定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为**回流（Reflow）**。

4. 绘制（Paint）
    
    遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为**重绘（Repaint）**。实际上，绘制过程是在多个层上完成的，这些层我们称为渲染层（RenderLayer）。

5. 渲染层合成（Composite）

    多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。

 从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化。


## 什么是渲染层合成 

在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示（想象一下ps中的合并图层，此处是将渲染层合并），生成一个GraphicsLayer，然而有特殊的渲染层（即合成层 CompositingLayer）会单独生成一个GraphicsLayer。

这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。

对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。


## 几个概念： 

- 渲染对象（RenderObject）
  
    一个 DOM 节点对应了一个渲染对象，渲染对象依然维持着 DOM 树的树形结构。一个渲染对象知道如何绘制一个 DOM 节点的内容，它通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 DOM 节点。

- 渲染层（RenderLayers)
    
    这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。比如有明确的position属性，或者opacity < 1，或者设置了filter，有transform属性且值不为none，或者overflow不为visible，有对opacity、transform、fliter应用动画等等（只要出现层叠关系，就会创建新的渲染层）

- 图形层（GraphicsLayer)

    GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。

    所以 GraphicsLayer 是一个重要的渲染载体和工具，但它并不直接处理渲染层，而是处理合成层。

- 合成层（CompositingLayer）

    满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。

## 渲染层提升为合成层的条件

那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：

- 3D transforms：translate3d、translateZ 等

- video、3D 或者 硬件加速的 2D Canvas 元素、硬件加速的 iframe 元素（比如页面中有合成层）

- 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition

- will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）

- position : fixed 定位

- 有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性

- 有合成层后代同时本身 overflow 不为 visible



## 隐式合成

上边提到，满足某些显性的特殊条件时，渲染层会被浏览器提升为合成层。除此之外，在浏览器的 Composite 阶段，还存在一种隐式合成，部分渲染层在一些特定场景下，会被默认提升为合成层。

举个例子

- 两个 absolute 定位的 div 在屏幕上交叠了，根据 z-index 的关系，其中一个 div 就会”盖在“了另外一个上边。

    <img src="/img/explore/render_1.jpg" />

- 这个时候，如果处于下方的 div 被加上了 CSS 属性：transform: translateZ(0)，就会被浏览器提升为合成层。提升后的合成层位于 Document 上方，假如没有隐式合成，原本应该处于上方的 div 就依然还是跟 Document 共用一个 GraphicsLayer，层级反而降了，就出现了元素交叠关系错乱的问题。

    <img src="/img/explore/render_2.jpg" />

- 所以为了纠正错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。

    <img src="/img/explore/render_3.jpg">

## 层压缩

基本上常见的一些合成层的提升原因如上所说，你会发现，由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处理。如果多个渲染层同一个合成层重叠时，这些隐式合成的多个渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”

## 层爆炸

一些产生合成层的原因太过于隐蔽了，尤其是隐式合成。在平时的开发过程中，我们很少会去关注层合成的问题，很容易就产生一些不在预期范围内的合成层，当这些不符合预期的合成层达到一定量级时，就会变成层爆炸。浏览器自身的层压缩并不能百分百的避免层爆炸的发生。

## 提升为合成层的好处

- 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
  
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
  
- 对于 transform 和 opacity 效果，不会触发 layout 和 paint


## 基于合成层的性能优化

主要思路是通过合成层相互独立的特性来减少不必要的回流和重绘，以及启用GPU加速

- **提升动画效果的元素**
  
    合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。

    提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层

    但需要注意的是，不要创建太多的合成层。因为每创建一个新的合成层，就意味着新的内存分配和更复杂的层的管理。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。

    如果你已经把一个元素放到一个新的合成层里，那么可以使用 Chrome Devtools Layers 里面的 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。

- **使用 transform 或者 opacity 来实现动画效果**

    普通的脱离文档流并不一定能避免回流和重绘，如absolute。
    减少渲染层的创建，就能减少浏览器渲染流程中布局和绘制阶段所需要的时间。

- **减少绘制区域**

    对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。

    而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。

    减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。

## 回流和重绘

### 回流

当页面布局和几何属性改变时就需要回流(影响到了自身在文档流中的位置)。

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素的增加或删除
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除可见的DOM元素
- 激活CSS伪类（例如：:hover）
- 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：

`clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
scrollIntoView()、scrollIntoViewIfNeeded()
getComputedStyle()
getBoundingClientRect()
scrollTo()`

访问这些方法会使得浏览器重新进行一次布局计算，而回流也会导致新的的布局渲染

### 重绘

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

### 性能影响

>回流必将引起重绘，重绘不一定会引起回流。

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。
现代浏览器会对频繁的回流或重绘操作进行优化：
浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

### 如何减少回流和重绘

CSS方面：

- 避免使用table布局
  
- 尽可能在DOM树的最末端改变class
  
- 避免设置多层内联样式
  
- 将动画效果应用到position属性为absolute或fixed的元素上（脱离文档流以避免父元素及相邻元素的回流）
  
- 避免使用CSS表达式（例如：calc()）

JS方面

- 合并你所有可能触发回流的操作（包括操作DOM，添加class，修改style）
  
- 可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。

- 避免频繁调用会引发回流的API，可以用一个变量缓存起来