(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{234:function(v,_,e){"use strict";e.r(_);var t=e(0),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"tcp协议与dns协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议与dns协议"}},[v._v("#")]),v._v(" TCP协议与DNS协议")]),v._v(" "),e("h2",{attrs:{id:"网络分层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络分层"}},[v._v("#")]),v._v(" 网络分层")]),v._v(" "),e("ul",[e("li",[v._v("物理层")]),v._v(" "),e("li",[v._v("数据链路层 (以太网)")]),v._v(" "),e("li",[v._v("网络层（IP）")]),v._v(" "),e("li",[v._v("传输层（TCP UDP)")]),v._v(" "),e("li",[v._v("（TLS/SSL 在这里，属于会话层和表示层）")]),v._v(" "),e("li",[v._v("应用层（HTTP, DNS, FTP, SMTP(邮件)）")])]),v._v(" "),e("h2",{attrs:{id:"tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),e("h3",{attrs:{id:"tcp-协议的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议的特点"}},[v._v("#")]),v._v(" TCP 协议的特点")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("面向连接")]),v._v(" "),e("p",[v._v("面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。")])]),v._v(" "),e("li",[e("p",[v._v("仅支持单播传输")]),v._v(" "),e("p",[v._v("每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。")])]),v._v(" "),e("li",[e("p",[v._v("面向字节流")]),v._v(" "),e("p",[v._v("TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。")])]),v._v(" "),e("li",[e("p",[v._v("可靠传输")]),v._v(" "),e("p",[v._v("对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。")])]),v._v(" "),e("li",[e("p",[v._v("提供拥塞控制")]),v._v(" "),e("p",[v._v("当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞")])]),v._v(" "),e("li",[e("p",[v._v("TCP 提供全双工通信")]),v._v(" "),e("p",[v._v("TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）")])])]),v._v(" "),e("h3",{attrs:{id:"tcp-三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手"}},[v._v("#")]),v._v(" TCP 三次握手")]),v._v(" "),e("blockquote",[e("p",[v._v("客户端：我想和你建立连接。")])]),v._v(" "),e("blockquote",[e("p",[v._v("服务端：ok，我现在可以和你建立连接。")])]),v._v(" "),e("blockquote",[e("p",[v._v("客户端：好的，那我们现在开始连接吧。")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("第一次握手：客户端发送一个 TCP 标志位 SYN=1，ACK=0 的数据包给服务端，并随机会产生一个 Sequence number=3233.当服务端接收到这个数据后，服务端由 SYN=1 可知客户端是想要建立连接；")])]),v._v(" "),e("li",[e("p",[v._v("第二次握手：服务端要对客户端的联机请求进行确认，向客户端发送应答号 ACK=1、SYN=1\n确认号 Acknowledge number=3234，此值是客户端的序列号加 1，还会产生一个随机的序列号 Sequence number=36457，这样就告诉客户端可以进行连接；")])]),v._v(" "),e("li",[e("p",[v._v("第三次握手：客户端收到数据后检查 Acknowledge number 是否是 3233+1 的值，以及 ACK 的值是否为 1，若为 1，host1 会发送 ACK=1、确认号码 Acknowledge number=36457，告诉服务端,你的请求连接被确认，连接可以建立。")])])]),v._v(" "),e("h3",{attrs:{id:"tcp-四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[v._v("#")]),v._v(" TCP 四次挥手")]),v._v(" "),e("blockquote",[e("p",[v._v("客户端：我准备断开连接了。")])]),v._v(" "),e("blockquote",[e("p",[v._v("服务端：ok，但是我这边可能还有一些数据要传，等我传我我会通知你。")])]),v._v(" "),e("blockquote",[e("p",[v._v("服务端：我传完了，可以断开连接了。")])]),v._v(" "),e("blockquote",[e("p",[v._v("客户端：ok，你断开连接吧。")])]),v._v(" "),e("blockquote",[e("p",[v._v("服务端：收到客户端最后一次信息后断开连接，未收到就会要求客户端重新发送关闭信息；\n客户端：发送最后一次信息后等待 2MLS(2 倍报文最大生存时间)，没有收到服务端的重传请求就关闭自己的连接")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("第一次挥手：当传输的数据到达尾部时，客户端向服务端发送 FIN=1 标志位；可理解成，客户端向服务端说，我这边的数据传送完成了，我准备断开了连接；")])]),v._v(" "),e("li",[e("p",[v._v("第二次挥手：因 TCP 的连接是全双工的双向连接，关闭也是要从两边关闭；当服务端收到客户端发来的 FIN=1 的标志位后，服务端不会立刻向客户端发送 FIND=1 的请求关闭信息，\n而是先向客户端发送一个 ACK=1 的应答信息，表示：你请求关闭的请求我已经收到，但我可能还有数据没有完成传送，你再等下，等我数据传输完成了我就告诉你；")])]),v._v(" "),e("li",[e("p",[v._v("第三次挥手：服务端数据传输完成，向客户端发送 FIN=1，客户端收到请求关闭连接的请求后，客户端就明白服务端的数据已传输完成，现在可以断开连接了，")])]),v._v(" "),e("li",[e("p",[v._v("第四次挥手：客户端收到 FIND=1 后，客户端还是怕由于网络不稳定的原因，怕服务端不知道他要断开连接，于是向服务端发送 ACK=1 确认信息进行确认，\n把自己设置成 TIME_WAIT 状态并启动定时器，如果服务端没有收到 ACK，服务端 TCP 的定时器到达后，会要求客户端重新发送 ACK，当服务端收到 ACK 后，服务端就断开连接；\n当客户端等待 2MLS（2 倍报文最大生存时间）后，没有收到服务端的重传请求后，他就知道服务端已收到了 ACK，所以客户端此时才关闭自己的连接。")])])]),v._v(" "),e("h2",{attrs:{id:"dns"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns"}},[v._v("#")]),v._v(" DNS")]),v._v(" "),e("p",[v._v("DNS (Domain Name System)， 也叫网域名称系统，是互联网的一项服务。它实质上是一个 域名 和 IP 相互映射的分布式数据库，有了它，我们就可以通过域名更方便的访问互联网。")]),v._v(" "),e("p",[v._v("DNS服务 使用 UDP 协议发送查询请求。")]),v._v(" "),e("h3",{attrs:{id:"域名级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#域名级别"}},[v._v("#")]),v._v(" 域名级别")]),v._v(" "),e("p",[v._v("域名级别是网址分类的一个标准，包括顶级域名、二级域名等。一个完整的域名由二个或二个以上部分组成，各部分之间用英文的句号"),e("code",[v._v(".")]),v._v("来分隔，倒数第一个"),e("code",[v._v(".")]),v._v("的右边部分称为顶级域名（TLD，也称为一级域名，包含一个合法字符串，和一个域名后缀），顶级域名的左边部分字符串到下个"),e("code",[v._v(".")]),v._v("为止称为二级域名（SLD），二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。所有域名后面其实都有一个隐藏的"),e("code",[v._v(".")]),v._v("，代表根域名。")]),v._v(" "),e("p",[v._v("拿 "),e("code",[v._v("www.baidu.com")]),v._v(" 来说  顶级域名com 二级域名baidu 三级域名www")]),v._v(" "),e("h3",{attrs:{id:"dns解析流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns解析流程"}},[v._v("#")]),v._v(" DNS解析流程")]),v._v(" "),e("p",[v._v("默认是先查找hosts文件，如果没有匹配到，再进行DNS解析")]),v._v(" "),e("ol",[e("li",[v._v("客户端向本地DNS服务器(递归解析服务器) 发出解析 "),e("code",[v._v("www.baidu.com")]),v._v(" 域名的请求")]),v._v(" "),e("li",[v._v("本地DNS服务器查看缓存，是否有缓存过 "),e("code",[v._v("www.baidu.com")]),v._v(" 域名，如果有直接返回给客户端，如果没有执行下一步")]),v._v(" "),e("li",[v._v("本地DNS服务器向根域名服务器发送请求，查询 com 顶级域的 nameserver 地址")]),v._v(" "),e("li",[v._v("拿到com域名的IP后，再向 com nameserver 发送请求，获取 baidu 域名的nameserver 地址")]),v._v(" "),e("li",[v._v("继续请求 baidu 的 nameserver, 获取 www 域名的地址，最终得到了 "),e("code",[v._v("www.baidu.com")]),v._v(" 的IP，本地DNS服务器把这个结果缓存起来，以供下次查询快速返回")]),v._v(" "),e("li",[v._v("本地DNS服务器把把结果返回给客户端")])]),v._v(" "),e("h3",{attrs:{id:"递归服务器-与-权威域名服务器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#递归服务器-与-权威域名服务器"}},[v._v("#")]),v._v(" 递归服务器 与 权威域名服务器")]),v._v(" "),e("p",[v._v("我们在解析流程中发现两类DNS服务器，客户端直接访问的是 递归解析服务器， 它在整个解析过程中也最忙。 它的查询步骤是递归的，从根域名服务器开始，一直询问到目标域名。")]),v._v(" "),e("p",[v._v("递归解析服务器通过请求一级一级的权威域名服务器，获得下一目标的地址，直到找到目标域名的 权威域名服务器")]),v._v(" "),e("p",[v._v("简单来说： 递归解析服务器 是负责解析域名的， 权威域名服务器 是负责存储域名记录的")]),v._v(" "),e("p",[v._v("递归服务器一般由互联网服务提供商提供（电信移动联通）")]),v._v(" "),e("h3",{attrs:{id:"分级缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分级缓存"}},[v._v("#")]),v._v(" 分级缓存")]),v._v(" "),e("p",[v._v("由于整个解析过程非常复杂，所以DNS 通过缓存技术来实现服务的鲁棒性。 当递归nameserver解析过 "),e("code",[v._v("www.baidu.com")]),v._v(" 域名后，再次收到 "),e("code",[v._v("www.baidu.com")]),v._v(" 查询时，它不会再走一遍递归解析流程，而是把上一次解析结果的缓存直接返回。 并且它是分级缓存的，也就是说，当下次收到的是 "),e("code",[v._v("www.baidu.com")]),v._v(" 的查询时， 由于这台递归解析服务器已经知道 "),e("code",[v._v("baidu.com")]),v._v(" 的权威 nameserver, 所以它只需要再向 "),e("code",[v._v("baidu.com")]),v._v(" nameserver 发送一个查询www的请求就可以了。")])])}),[],!1,null,null,null);_.default=a.exports}}]);