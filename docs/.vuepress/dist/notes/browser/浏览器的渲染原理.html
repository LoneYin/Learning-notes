<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器的渲染原理 | 学习笔记</title>
    <meta name="description" content="构建自己的前端知识体系">
    
    
    <link rel="preload" href="/assets/css/0.styles.a4aa4dff.css" as="style"><link rel="preload" href="/assets/js/app.a31d5691.js" as="script"><link rel="preload" href="/assets/js/2.ddf9653e.js" as="script"><link rel="preload" href="/assets/js/22.2786dcc7.js" as="script"><link rel="prefetch" href="/assets/js/10.803e4d7e.js"><link rel="prefetch" href="/assets/js/11.9b589f78.js"><link rel="prefetch" href="/assets/js/12.2c631f17.js"><link rel="prefetch" href="/assets/js/13.ed532cf2.js"><link rel="prefetch" href="/assets/js/14.bc847dfe.js"><link rel="prefetch" href="/assets/js/15.194eeda8.js"><link rel="prefetch" href="/assets/js/16.3a145252.js"><link rel="prefetch" href="/assets/js/17.9bde0b7b.js"><link rel="prefetch" href="/assets/js/18.fae57c73.js"><link rel="prefetch" href="/assets/js/19.8757e714.js"><link rel="prefetch" href="/assets/js/20.6d76ab7e.js"><link rel="prefetch" href="/assets/js/21.1a964119.js"><link rel="prefetch" href="/assets/js/23.e8df8377.js"><link rel="prefetch" href="/assets/js/24.4485f615.js"><link rel="prefetch" href="/assets/js/25.a9579c95.js"><link rel="prefetch" href="/assets/js/26.c372ecb9.js"><link rel="prefetch" href="/assets/js/27.b36f9827.js"><link rel="prefetch" href="/assets/js/28.566c95d4.js"><link rel="prefetch" href="/assets/js/29.50b60a1c.js"><link rel="prefetch" href="/assets/js/3.df3a87d4.js"><link rel="prefetch" href="/assets/js/30.58b622a8.js"><link rel="prefetch" href="/assets/js/31.3c3e73dd.js"><link rel="prefetch" href="/assets/js/32.c7bb1c1f.js"><link rel="prefetch" href="/assets/js/33.6bc9ec15.js"><link rel="prefetch" href="/assets/js/34.f91d14e7.js"><link rel="prefetch" href="/assets/js/35.7b39f7b8.js"><link rel="prefetch" href="/assets/js/36.021c5937.js"><link rel="prefetch" href="/assets/js/37.4441c601.js"><link rel="prefetch" href="/assets/js/4.554dccb8.js"><link rel="prefetch" href="/assets/js/5.7ec69b64.js"><link rel="prefetch" href="/assets/js/6.fd22e7cc.js"><link rel="prefetch" href="/assets/js/7.55ca8e68.js"><link rel="prefetch" href="/assets/js/8.e401c731.js"><link rel="prefetch" href="/assets/js/9.6cc258f0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a4aa4dff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">前端笔记</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">前端笔记</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/browser/浏览器的进程与线程.html" class="sidebar-link">浏览器的进程与线程</a></li><li><a href="/notes/browser/浏览器的渲染原理.html" class="active sidebar-link">浏览器的渲染原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#浏览器的渲染流程" class="sidebar-link">浏览器的渲染流程</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#什么是渲染层合成" class="sidebar-link">什么是渲染层合成</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#几个概念：" class="sidebar-link">几个概念：</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#渲染层提升为合成层的条件" class="sidebar-link">渲染层提升为合成层的条件</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#隐式合成" class="sidebar-link">隐式合成</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#层压缩" class="sidebar-link">层压缩</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#层爆炸" class="sidebar-link">层爆炸</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#提升为合成层的好处" class="sidebar-link">提升为合成层的好处</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#基于合成层的性能优化" class="sidebar-link">基于合成层的性能优化</a></li><li class="sidebar-sub-header"><a href="/notes/browser/浏览器的渲染原理.html#回流和重绘" class="sidebar-link">回流和重绘</a></li></ul></li><li><a href="/notes/browser/浏览器JS引擎.html" class="sidebar-link">浏览器JS引擎（V8）</a></li><li><a href="/notes/browser/浏览器EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/notes/browser/浏览器缓存策略.html" class="sidebar-link">浏览器缓存策略</a></li><li><a href="/notes/browser/跨域与页面通信.html" class="sidebar-link">跨域与页面通信</a></li><li><a href="/notes/browser/浏览器DOM事件与事件监听.html" class="sidebar-link">浏览器DOM事件与事件监听</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/network/网络知识.html" class="sidebar-link">网络知识</a></li><li><a href="/notes/network/Web安全.html" class="sidebar-link">Web安全 —— XSS 与 CSRF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/advanced/JS执行上下文栈.html" class="sidebar-link">JS执行上下文栈</a></li><li><a href="/notes/advanced/原型链与继承.html" class="sidebar-link">原型链继承</a></li><li><a href="/notes/advanced/Generator.html" class="sidebar-link">Generator</a></li><li><a href="/notes/advanced/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/notes/advanced/Proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/notes/advanced/节流和防抖.html" class="sidebar-link">函数的节流和防抖</a></li><li><a href="/notes/advanced/函数柯里化.html" class="sidebar-link">函数柯里化</a></li><li><a href="/notes/advanced/bind和call和apply.html" class="sidebar-link">bind-call-apply</a></li><li><a href="/notes/advanced/常见算法.html" class="sidebar-link">常见算法</a></li><li><a href="/notes/advanced/单例模式.html" class="sidebar-link">JavaScript 中单例设计模式的应用</a></li><li><a href="/notes/advanced/观察者模式.html" class="sidebar-link">观察者模式的简单实现</a></li><li><a href="/notes/advanced/使用setTimeout模拟setInterval.html" class="sidebar-link">封装一个 Timer 类，用 setTimeout 实现 setInterval</a></li><li><a href="/notes/advanced/new运算符.html" class="sidebar-link">JavaScript中的new运算符到底做了什么</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/others/模块加载机制.html" class="sidebar-link">模块加载机制</a></li><li><a href="/notes/others/前端性能优化.html" class="sidebar-link">前端性能优化</a></li><li><a href="/notes/others/移动端适配方案.html" class="sidebar-link">移动端适配方案</a></li><li><a href="/notes/others/Vue与React的区别.html" class="sidebar-link">Vue与React的区别</a></li><li><a href="/notes/others/面试题整理.html" class="sidebar-link">一些JS面试题整理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>个人随笔</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/essay/给ReactRouter添加转场动画.html" class="sidebar-link">给React-Router添加路由页面切换时的过渡动画</a></li><li><a href="/notes/essay/Vue列表渲染中的key的作用.html" class="sidebar-link">key在Vue渲染列表时究竟起到了什么作用</a></li><li><a href="/notes/essay/vue源码阅读知识点整理.html" class="sidebar-link">Vue 源码阅读知识点整理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="header-anchor">#</a> 浏览器的渲染原理</h1> <h2 id="浏览器的渲染流程"><a href="#浏览器的渲染流程" class="header-anchor">#</a> 浏览器的渲染流程</h2> <ol><li><p>构建DOM树</p> <p>浏览器主进程将 html 传给渲染进程，渲染进程会解析文本字符串为树形结构的 DOM 树。一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候。渲染 html 为 DOM 的方法由 HTML Standard 定义。</p></li> <li><p>构建渲染树</p> <p>CSS文件加载完毕，浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树（RenderObject Tree）。</p></li> <li><p>布局（Layout)</p> <p>浏览器根据渲染树所体现的节点、各个节点的CSS定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为<strong>回流（Reflow）</strong>。</p></li> <li><p>绘制（Paint）</p> <p>遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为<strong>重绘（Repaint）</strong>。实际上，绘制过程是在多个层上完成的，这些层我们称为渲染层（RenderLayer）。</p></li> <li><p>渲染层合成（Composite）</p> <p>多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。</p></li></ol> <p>从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化。</p> <h2 id="什么是渲染层合成"><a href="#什么是渲染层合成" class="header-anchor">#</a> 什么是渲染层合成</h2> <p>在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示（想象一下ps中的合并图层，此处是将渲染层合并），生成一个GraphicsLayer，然而有特殊的渲染层（即合成层 CompositingLayer）会单独生成一个GraphicsLayer。</p> <p>这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。</p> <p>对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p> <h2 id="几个概念："><a href="#几个概念：" class="header-anchor">#</a> 几个概念：</h2> <ul><li><p>渲染对象（RenderObject）</p> <p>一个 DOM 节点对应了一个渲染对象，渲染对象依然维持着 DOM 树的树形结构。一个渲染对象知道如何绘制一个 DOM 节点的内容，它通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 DOM 节点。</p></li> <li><p>渲染层（RenderLayers)</p> <p>这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。比如有明确的position属性，或者opacity &lt; 1，或者设置了filter，有transform属性且值不为none，或者overflow不为visible，有对opacity、transform、fliter应用动画等等（只要出现层叠关系，就会创建新的渲染层）</p></li> <li><p>图形层（GraphicsLayer)</p> <p>GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。</p> <p>所以 GraphicsLayer 是一个重要的渲染载体和工具，但它并不直接处理渲染层，而是处理合成层。</p></li> <li><p>合成层（CompositingLayer）</p> <p>满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。</p></li></ul> <h2 id="渲染层提升为合成层的条件"><a href="#渲染层提升为合成层的条件" class="header-anchor">#</a> 渲染层提升为合成层的条件</h2> <p>那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：</p> <ul><li><p>3D transforms：translate3d、translateZ 等</p></li> <li><p>video、3D 或者 硬件加速的 2D Canvas 元素、硬件加速的 iframe 元素（比如页面中有合成层）</p></li> <li><p>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</p></li> <li><p>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）</p></li> <li><p>position : fixed 定位</p></li> <li><p>有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性</p></li> <li><p>有合成层后代同时本身 overflow 不为 visible</p></li></ul> <h2 id="隐式合成"><a href="#隐式合成" class="header-anchor">#</a> 隐式合成</h2> <p>上边提到，满足某些显性的特殊条件时，渲染层会被浏览器提升为合成层。除此之外，在浏览器的 Composite 阶段，还存在一种隐式合成，部分渲染层在一些特定场景下，会被默认提升为合成层。</p> <p>举个例子</p> <ul><li><p>两个 absolute 定位的 div 在屏幕上交叠了，根据 z-index 的关系，其中一个 div 就会”盖在“了另外一个上边。</p> <img src="/img/explore/render_1.jpg"></li> <li><p>这个时候，如果处于下方的 div 被加上了 CSS 属性：transform: translateZ(0)，就会被浏览器提升为合成层。提升后的合成层位于 Document 上方，假如没有隐式合成，原本应该处于上方的 div 就依然还是跟 Document 共用一个 GraphicsLayer，层级反而降了，就出现了元素交叠关系错乱的问题。</p> <img src="/img/explore/render_2.jpg"></li> <li><p>所以为了纠正错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。</p> <img src="/img/explore/render_3.jpg"></li></ul> <h2 id="层压缩"><a href="#层压缩" class="header-anchor">#</a> 层压缩</h2> <p>基本上常见的一些合成层的提升原因如上所说，你会发现，由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处理。如果多个渲染层同一个合成层重叠时，这些隐式合成的多个渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”</p> <h2 id="层爆炸"><a href="#层爆炸" class="header-anchor">#</a> 层爆炸</h2> <p>一些产生合成层的原因太过于隐蔽了，尤其是隐式合成。在平时的开发过程中，我们很少会去关注层合成的问题，很容易就产生一些不在预期范围内的合成层，当这些不符合预期的合成层达到一定量级时，就会变成层爆炸。浏览器自身的层压缩并不能百分百的避免层爆炸的发生。</p> <h2 id="提升为合成层的好处"><a href="#提升为合成层的好处" class="header-anchor">#</a> 提升为合成层的好处</h2> <ul><li><p>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</p></li> <li><p>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</p></li> <li><p>对于 transform 和 opacity 效果，不会触发 layout 和 paint</p></li></ul> <h2 id="基于合成层的性能优化"><a href="#基于合成层的性能优化" class="header-anchor">#</a> 基于合成层的性能优化</h2> <p>主要思路是通过合成层相互独立的特性来减少不必要的回流和重绘，以及启用GPU加速</p> <ul><li><p><strong>提升动画效果的元素</strong></p> <p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。</p> <p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层</p> <p>但需要注意的是，不要创建太多的合成层。因为每创建一个新的合成层，就意味着新的内存分配和更复杂的层的管理。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p> <p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Chrome Devtools Layers 里面的 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p></li> <li><p><strong>使用 transform 或者 opacity 来实现动画效果</strong></p> <p>普通的脱离文档流并不一定能避免回流和重绘，如absolute。
减少渲染层的创建，就能减少浏览器渲染流程中布局和绘制阶段所需要的时间。</p></li> <li><p><strong>减少绘制区域</strong></p> <p>对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。</p> <p>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。</p> <p>减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</p></li></ul> <h2 id="回流和重绘"><a href="#回流和重绘" class="header-anchor">#</a> 回流和重绘</h2> <h3 id="回流"><a href="#回流" class="header-anchor">#</a> 回流</h3> <p>当页面布局和几何属性改变时就需要回流(影响到了自身在文档流中的位置)。</p> <ul><li>页面首次渲染</li> <li>浏览器窗口大小发生改变</li> <li>元素尺寸或位置发生改变</li> <li>元素的增加或删除</li> <li>元素内容变化（文字数量或图片大小等等）</li> <li>元素字体大小变化</li> <li>添加或者删除可见的DOM元素</li> <li>激活CSS伪类（例如：:hover）</li> <li>查询某些属性或调用某些方法</li></ul> <p>一些常用且会导致回流的属性和方法：</p> <p><code>clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo()</code></p> <p>访问这些方法会使得浏览器重新进行一次布局计算，而回流也会导致新的的布局渲染</p> <h3 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h3> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <h3 id="性能影响"><a href="#性能影响" class="header-anchor">#</a> 性能影响</h3> <blockquote><p>回流必将引起重绘，重绘不一定会引起回流。</p></blockquote> <p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。
现代浏览器会对频繁的回流或重绘操作进行优化：
浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p> <h3 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="header-anchor">#</a> 如何减少回流和重绘</h3> <p>CSS方面：</p> <ul><li><p>避免使用table布局</p></li> <li><p>尽可能在DOM树的最末端改变class</p></li> <li><p>避免设置多层内联样式</p></li> <li><p>将动画效果应用到position属性为absolute或fixed的元素上（脱离文档流以避免父元素及相邻元素的回流）</p></li> <li><p>避免使用CSS表达式（例如：calc()）</p></li></ul> <p>JS方面</p> <ul><li><p>合并你所有可能触发回流的操作（包括操作DOM，添加class，修改style）</p></li> <li><p>可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</p></li> <li><p>避免频繁调用会引发回流的API，可以用一个变量缓存起来</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/browser/浏览器的进程与线程.html" class="prev">浏览器的进程与线程</a></span> <span class="next"><a href="/notes/browser/浏览器JS引擎.html">浏览器JS引擎（V8）</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a31d5691.js" defer></script><script src="/assets/js/2.ddf9653e.js" defer></script><script src="/assets/js/22.2786dcc7.js" defer></script>
  </body>
</html>
