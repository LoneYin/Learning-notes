<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一些JS面试题整理 | 学习笔记</title>
    <meta name="description" content="构建自己的前端知识体系">
    
    
    <link rel="preload" href="/assets/css/0.styles.a4aa4dff.css" as="style"><link rel="preload" href="/assets/js/app.d90b1a7d.js" as="script"><link rel="preload" href="/assets/js/2.ddf9653e.js" as="script"><link rel="preload" href="/assets/js/41.ca3e1133.js" as="script"><link rel="prefetch" href="/assets/js/10.2822c8d4.js"><link rel="prefetch" href="/assets/js/11.953eb217.js"><link rel="prefetch" href="/assets/js/12.08cd3bc9.js"><link rel="prefetch" href="/assets/js/13.3ea07363.js"><link rel="prefetch" href="/assets/js/14.08d3c49e.js"><link rel="prefetch" href="/assets/js/15.99b05918.js"><link rel="prefetch" href="/assets/js/16.9b87fae1.js"><link rel="prefetch" href="/assets/js/17.e263599c.js"><link rel="prefetch" href="/assets/js/18.a9e58c70.js"><link rel="prefetch" href="/assets/js/19.450252cb.js"><link rel="prefetch" href="/assets/js/20.67219f9a.js"><link rel="prefetch" href="/assets/js/21.83fb62ce.js"><link rel="prefetch" href="/assets/js/22.454161a4.js"><link rel="prefetch" href="/assets/js/23.cd0dc78c.js"><link rel="prefetch" href="/assets/js/24.62650fe5.js"><link rel="prefetch" href="/assets/js/25.5fa89824.js"><link rel="prefetch" href="/assets/js/26.69c19d16.js"><link rel="prefetch" href="/assets/js/27.014678fc.js"><link rel="prefetch" href="/assets/js/28.f12de4e4.js"><link rel="prefetch" href="/assets/js/29.7699ebd7.js"><link rel="prefetch" href="/assets/js/3.b0a6775b.js"><link rel="prefetch" href="/assets/js/30.9261d85c.js"><link rel="prefetch" href="/assets/js/31.57536ebb.js"><link rel="prefetch" href="/assets/js/32.a73b6dce.js"><link rel="prefetch" href="/assets/js/33.36884a86.js"><link rel="prefetch" href="/assets/js/34.79921d3e.js"><link rel="prefetch" href="/assets/js/35.f0f27945.js"><link rel="prefetch" href="/assets/js/36.2a08bebc.js"><link rel="prefetch" href="/assets/js/37.294494f7.js"><link rel="prefetch" href="/assets/js/38.20d8a33d.js"><link rel="prefetch" href="/assets/js/39.5bc82999.js"><link rel="prefetch" href="/assets/js/4.554dccb8.js"><link rel="prefetch" href="/assets/js/40.b64c9fda.js"><link rel="prefetch" href="/assets/js/42.34bdf90e.js"><link rel="prefetch" href="/assets/js/5.7ec69b64.js"><link rel="prefetch" href="/assets/js/6.9a961699.js"><link rel="prefetch" href="/assets/js/7.7e6eebce.js"><link rel="prefetch" href="/assets/js/8.4a1300d9.js"><link rel="prefetch" href="/assets/js/9.5d664d52.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a4aa4dff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">前端笔记</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">前端笔记</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/browser/浏览器的进程与线程.html" class="sidebar-link">浏览器的进程与线程</a></li><li><a href="/notes/browser/浏览器的渲染原理.html" class="sidebar-link">浏览器的渲染原理</a></li><li><a href="/notes/browser/浏览器JS引擎.html" class="sidebar-link">浏览器JS引擎（V8）</a></li><li><a href="/notes/browser/浏览器EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/notes/browser/浏览器缓存策略.html" class="sidebar-link">浏览器缓存策略</a></li><li><a href="/notes/browser/跨域与页面通信.html" class="sidebar-link">跨域与页面通信</a></li><li><a href="/notes/browser/浏览器DOM事件与事件监听.html" class="sidebar-link">浏览器DOM事件与事件监听</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/network/TCP与DNS.html" class="sidebar-link">TCP协议与DNS协议</a></li><li><a href="/notes/network/HTTP协议.html" class="sidebar-link">HTTP/HTTPS/HTTP2</a></li><li><a href="/notes/network/GET和POST请求的区别.html" class="sidebar-link">GET请求和POST请求的区别</a></li><li><a href="/notes/network/Web安全.html" class="sidebar-link">Web安全 —— XSS 与 CSRF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/advanced/JS执行上下文栈.html" class="sidebar-link">JS执行上下文栈</a></li><li><a href="/notes/advanced/原型链与继承.html" class="sidebar-link">原型链继承</a></li><li><a href="/notes/advanced/Iterator和Generator.html" class="sidebar-link">Iterator和Generator</a></li><li><a href="/notes/advanced/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/notes/advanced/Proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/notes/advanced/节流和防抖.html" class="sidebar-link">函数的节流和防抖</a></li><li><a href="/notes/advanced/函数柯里化.html" class="sidebar-link">函数柯里化和偏函数</a></li><li><a href="/notes/advanced/bind和call和apply.html" class="sidebar-link">手写 bind/call/apply</a></li><li><a href="/notes/advanced/另一个角度理解this.html" class="sidebar-link">从另一个角度理解this</a></li><li><a href="/notes/advanced/闭包.html" class="sidebar-link">闭包</a></li><li><a href="/notes/advanced/常见算法.html" class="sidebar-link">常见算法</a></li><li><a href="/notes/advanced/单例模式.html" class="sidebar-link">JavaScript 中单例设计模式的应用</a></li><li><a href="/notes/advanced/观察者模式.html" class="sidebar-link">观察者模式的简单实现</a></li><li><a href="/notes/advanced/使用setTimeout模拟setInterval.html" class="sidebar-link">用 setTimeout 实现 setInterval</a></li><li><a href="/notes/advanced/new运算符.html" class="sidebar-link">new运算符到底做了什么</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>其他知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/others/模块加载机制.html" class="sidebar-link">模块加载机制</a></li><li><a href="/notes/others/前端性能优化.html" class="sidebar-link">前端性能优化</a></li><li><a href="/notes/others/移动端适配方案.html" class="sidebar-link">移动端适配方案</a></li><li><a href="/notes/others/Vue与React的区别.html" class="sidebar-link">Vue与React的区别</a></li><li><a href="/notes/others/面试题整理.html" class="active sidebar-link">一些JS面试题整理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q1：输出以下代码的执行结果并解释为什么" class="sidebar-link">Q1：输出以下代码的执行结果并解释为什么</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q2：数组扁平化" class="sidebar-link">Q2：数组扁平化</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q3：-1-2-3-map-parseint-返回结果" class="sidebar-link">Q3：['1', '2', '3'].map(parseInt) 返回结果</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q4：" class="sidebar-link">Q4：[] == ![]</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q5-react中setstate在什么情况下是同步的？" class="sidebar-link">Q5: React中setState在什么情况下是同步的？</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q6-function-prototype-function-prototype" class="sidebar-link">Q6: Function[[prototype]] === Function.prototype?</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q7-为什么react的事件handler需要手动绑定this" class="sidebar-link">Q7: 为什么React的事件handler需要手动绑定this?</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q8-js函数的参数是如何传递的？" class="sidebar-link">Q8: js函数的参数是如何传递的？</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q9-object-is-判断原理" class="sidebar-link">Q9: Object.is 判断原理</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#_0-和-0" class="sidebar-link">+0 和 -0</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>个人随笔</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/essay/给ReactRouter添加转场动画.html" class="sidebar-link">给React-Router添加路由页面切换时的过渡动画</a></li><li><a href="/notes/essay/Vue列表渲染中的key的作用.html" class="sidebar-link">key在Vue渲染列表时究竟起到了什么作用</a></li><li><a href="/notes/essay/vue源码阅读知识点整理.html" class="sidebar-link">Vue 源码阅读知识点整理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一些js面试题整理"><a href="#一些js面试题整理" class="header-anchor">#</a> 一些JS面试题整理</h1> <h2 id="q1：输出以下代码的执行结果并解释为什么"><a href="#q1：输出以下代码的执行结果并解释为什么" class="header-anchor">#</a> Q1：输出以下代码的执行结果并解释为什么</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span>

a<span class="token punctuation">.</span>x <span class="token comment">// --&gt; undefined</span>
b<span class="token punctuation">.</span>x <span class="token comment">// --&gt; {n: 2}</span>
</code></pre></div><h3 id="解析："><a href="#解析：" class="header-anchor">#</a> 解析：</h3> <p><strong>运算符优先级和连续赋值带来的坑</strong></p> <p>首先，<code>a</code>和<code>b</code>同时引用了<code>{n:2}</code>对象，接着执行到<code>a.x = a = {n：2}</code>语句，尽管赋值是从右到左的没错，但是<code>.</code>的优先级比<code>=</code>要高，所以这里首先执行<code>a.x</code>，相当于为<code>a</code>（或者<code>b</code>）所指向的<code>{n:1}</code>对象新增了一个属性x，即此时对象将变为<code>{n:1;x:undefined}</code>。</p> <p>之后按正常情况，从右到左进行赋值，此时执行<code>a ={n:2}</code>的时候，<code>a</code>的引用改变，指向了新对象<code>{n：2}</code>,而<code>b</code>依然指向的是旧对象。之后执行<code>a.x = {n：2}</code>的时候，并不会重新解析一遍<code>a</code>，而是沿用最初解析<code>a.x</code>时候的<code>a</code>，也即旧对象，故此时旧对象的<code>x</code>的值为<code>{n：2}</code>，旧对象为 <code>{n:1;x:{n：2}}</code>，它被<code>b</code>引用着。</p> <p>后面输出<code>a.x</code>的时候，又要解析<code>a</code>了，此时的<code>a</code>是指向新对象的<code>a</code>，而这个新对象是没有<code>x</code>属性的，故访问时输出<code>undefined</code>；而访问<code>b.x</code>的时候，将输出旧对象的<code>x</code>的值，即<code>{n:2}</code>。</p> <h2 id="q2：数组扁平化"><a href="#q2：数组扁平化" class="header-anchor">#</a> Q2：数组扁平化</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// [[1,2,2],[3, 4, 5, 5],[6, 7, 8, 9,[11,12,[12,13,[14]]]],10]  ------&gt;   [1,2,2,3,4,5,5,6,7,8,9,11,12,12,13,14,10]</span>

<span class="token comment">// 递归法  可使用reduce map for循环等实现</span>
<span class="token comment">// reduce</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// map</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// for</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span class="token comment">// 转字符串法 不过只适用于纯数字数组</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="q3：-1-2-3-map-parseint-返回结果"><a href="#q3：-1-2-3-map-parseint-返回结果" class="header-anchor">#</a> Q3：['1', '2', '3'].map(parseInt) 返回结果</h2> <h3 id="arrray-map"><a href="#arrray-map" class="header-anchor">#</a> Arrray.map</h3> <p><code>Array.map</code>方法会遍历原数组中的每个元素并执行<code>callback</code>，返回一个新的数组</p> <ul><li><code>callback</code>的第一个参数是<code>currentValue</code>，也就是原数组中正在处理的当前元素</li> <li><code>callback</code>的第二个参数是<code>index</code>，是原数组中正在处理的当前元素的索引</li></ul> <h3 id="parseint"><a href="#parseint" class="header-anchor">#</a> parseInt</h3> <p><code>parseInt</code>方法解析一个字符串参数，并返回一个指定基数（进制）的整数</p> <ul><li><code>parseInt</code>的第一个参数是<code>string</code>，也就是要被解析的字符串的值</li> <li><code>parseInt</code>得第二个参数是<code>radix</code>，一个介于2和36之间的整数，默认为10，代表解析字符串的基数（进制数）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
</code></pre></div><p>等同于</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>即返回值分别为</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</span>
</code></pre></div><p>所以</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
<span class="token comment">// 1, NaN, NaN</span>
</code></pre></div><h2 id="q4："><a href="#q4：" class="header-anchor">#</a> Q4：[] == ![]</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// true</span>
</code></pre></div><h3 id="解析：-2"><a href="#解析：-2" class="header-anchor">#</a> 解析：</h3> <p><code>==</code> 运算符，<code>javascript</code>语言灵活性的代表但也是最臭名昭著的黑魔法之一，比较运算之中发生的隐式类型转化不知坑了多少JSer。</p> <p>我们先来列举一下<code>==</code>（相等运算符）的运算规则</p> <ul><li>如果两个值类型相同，进行 <code>====</code> （严格相等运算符） 比较</li> <li>如果两个值类型不同，它们可能是相等的，此时根据下列规则进行类型转换后比较:
<ol><li>如果一个值为<code>null</code>，另一个是<code>undefined</code>，那么<strong>相等</strong></li> <li>如果一个值是<code>String</code>，另一个是<code>Number</code>，在比较之前要先将<code>String</code>转换为<code>Number</code>，即调用<code>Number()</code>方法</li> <li>如果一个值是<code>Boolean</code>，则先将这个<code>Boolean</code>转换为数值后再进行比较，即调用<code>Number()</code>方法</li> <li>如果一个值是<code>Object</code>，另一个是<code>String</code>或<code>Number</code>，则先将对象转换为基本数据类型再比较，即调用<code>javascript</code>内置类的<code>valueOf</code>或<code>toString</code>方法，<code>valueOf</code>会先于<code>toString</code>，例外的是<code>Date</code>对象，会直接用<code>toString</code>转换</li></ol></li></ul> <p>接下来我们分析一下<code>[] == ![]</code>为什么返回<code>true</code></p> <ol><li>首先运算符右边的<code>![]</code>会先进行运算，得到<code>false</code>，即<code>[] == false</code></li> <li>当等式两边有<code>Boolean</code>值得时候会先对其进行类型转换，即<code>Number(false) = 0</code>，等式两边变为<code>[] == 0</code></li> <li>当等式两边一个值为<code>Object</code>另一个为<code>Number</code>时，将<code>Object</code>进行类型转换，即<code>[].valueOf()</code>，发现返回的结果<code>[]</code>仍是<code>Object</code>，所以再调用<code>[].toString()</code>得到<code>''</code>，<code>Number('')</code>得到<code>0</code></li> <li><code>0 == 0</code> 成立， 返回<code>true</code></li></ol> <h2 id="q5-react中setstate在什么情况下是同步的？"><a href="#q5-react中setstate在什么情况下是同步的？" class="header-anchor">#</a> Q5: React中setState在什么情况下是同步的？</h2> <p>在 React 中，如果是在 React 引发的事件处理方法（比如通过 onClick 引发的事件处理）或在生命周期中调用 setState 不会同步更新 this.state 。除此之外的 setState 调用会同步执行this.state。所谓<strong>除此之外</strong>，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。</p> <blockquote><p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。  —— <a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener noreferrer">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <blockquote><p>setState 的<strong>异步</strong>并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</p></blockquote> <blockquote><p>setState 的批量更新优化也是建立在<strong>异步</strong>（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在<strong>异步</strong>中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p></blockquote> <p>关于setState的具体内容详见大佬的文章<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="noopener noreferrer">《你真的理解setState吗？》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="q6-function-prototype-function-prototype"><a href="#q6-function-prototype-function-prototype" class="header-anchor">#</a> Q6: Function[[prototype]] === Function.prototype?</h2> <p>是对的  因为 Function 也是一个函数，它的__proto__指向 Function 构造函数的原型，很扯</p> <p>应该是现有 Function.prototype 然后有的 function Function()</p> <h2 id="q7-为什么react的事件handler需要手动绑定this"><a href="#q7-为什么react的事件handler需要手动绑定this" class="header-anchor">#</a> Q7: 为什么React的事件handler需要手动绑定this?</h2> <p>相对于其他框架来说，react使用了合成事件（SyntheticEvent）来标准化浏览器的事件。</p> <p>合成事件是一种顶层代理机制，这种代理机制作用的结果是：</p> <blockquote><p>事件依然在真实的dom节点上触发，之后会冒泡一路到document的节点，然后开始分发document节点收集到的事件，这个时候react从事件触发的组件实例开始， 遍历虚拟dom树，从树上取下我们绑定的事件，收集起来，然后执行。</p></blockquote> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
   <span class="token function-variable function">fatherHandler</span> <span class="token operator">=</span>  <span class="token keyword">function</span> <span class="token function">father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span><span class="token punctuation">}</span>
   <span class="token function-variable function">childHander</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span>
       <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fatherHandler<span class="token punctuation">}</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>span onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>childHander<span class="token punctuation">}</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当事件触发以后react会把上面的事件处理函数放到一个数组里是这样的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>father<span class="token punctuation">,</span> child<span class="token punctuation">]</span>
</code></pre></div><p>最后，react只要遍历执行这个数组，就能执行所有需要执行的事件处理函数。哈哈，想必眼尖的同学已经看出问题了，之前我们对函数进行了临时保存(简单粗暴的把事件处理函数赋值给了onClick属性)，这个时候执行的话，this自然就丢失了。有的同学也说了这其实不是react的锅，是js本身的问题。但是如果react保存顺便保存一下实例，还是可以做到，不需要你绑定this的，但是这样对于react来说代价太大了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">{</span>instance<span class="token punctuation">,</span> father<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>instance，child<span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre></div><h2 id="q8-js函数的参数是如何传递的？"><a href="#q8-js函数的参数是如何传递的？" class="header-anchor">#</a> Q8: js函数的参数是如何传递的？</h2> <blockquote><p>ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p></blockquote> <p>参数如果是基本类型是按值传递，如果是引用类型按共享传递。共享传递是指，在传递对象的时候，传递对象的引用的副本。</p> <p><strong>注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的<code>引用的副本</code>！</strong></p> <p>也就是说，你在函数内部直接修改作为参数传进来的对象的引用，是不会影响到原对象的引用的，但是你在没有改引用的状态下更改了对象某个属性的值，原对象也会变化</p> <h2 id="q9-object-is-判断原理"><a href="#q9-object-is-判断原理" class="header-anchor">#</a> Q9: Object.is 判断原理</h2> <p>Object.is() 判断两个值是否相同。如果下列任何一项成立，则两个值相同：</p> <ul><li><p>两个值都是 undefined</p></li> <li><p>两个值都是 null</p></li> <li><p>两个值都是 true 或者都是 false</p></li> <li><p>两个值是由相同个数的字符按照相同的顺序组成的字符串</p></li> <li><p>两个值指向同一个对象</p></li> <li><p>两个值都是数字并且</p> <ul><li>都是正零 +0</li> <li>都是负零 -0</li> <li>都是 NaN</li> <li>都是除零和 NaN 外的其它同一个数字</li></ul></li></ul> <h2 id="_0-和-0"><a href="#_0-和-0" class="header-anchor">#</a> +0 和 -0</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 也就是+0</span>
<span class="token number">0</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0</span> 

<span class="token number">0</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// true</span>
<span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// true</span>

<span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>   <span class="token comment">// Infinity</span>
<span class="token number">1</span><span class="token operator">/</span><span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// -Infinity</span>
<span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span> <span class="token comment">// false</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>当然+0与-0的存在也不是完全没有用处，我们有时会用符号位存储一些信息，比较向量或速度的方向信息,如速度-0,负号代表着运动的方向，保留了负号位可以防止这些信息的丢失。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/others/Vue与React的区别.html" class="prev">Vue与React的区别</a></span> <span class="next"><a href="/notes/essay/给ReactRouter添加转场动画.html">给React-Router添加路由页面切换时的过渡动画</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d90b1a7d.js" defer></script><script src="/assets/js/2.ddf9653e.js" defer></script><script src="/assets/js/41.ca3e1133.js" defer></script>
  </body>
</html>
