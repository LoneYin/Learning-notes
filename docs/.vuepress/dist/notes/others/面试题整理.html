<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一些JS面试题整理 | 学习笔记</title>
    <meta name="description" content="构建自己的前端知识体系">
    
    
    <link rel="preload" href="/assets/css/0.styles.a4aa4dff.css" as="style"><link rel="preload" href="/assets/js/app.a0ed42a3.js" as="script"><link rel="preload" href="/assets/js/2.ddf9653e.js" as="script"><link rel="preload" href="/assets/js/36.3b360b27.js" as="script"><link rel="prefetch" href="/assets/js/10.ccf87d42.js"><link rel="prefetch" href="/assets/js/11.bdd0eccd.js"><link rel="prefetch" href="/assets/js/12.3bc2fe76.js"><link rel="prefetch" href="/assets/js/13.55ae582b.js"><link rel="prefetch" href="/assets/js/14.08d3c49e.js"><link rel="prefetch" href="/assets/js/15.6c400659.js"><link rel="prefetch" href="/assets/js/16.3a145252.js"><link rel="prefetch" href="/assets/js/17.9bde0b7b.js"><link rel="prefetch" href="/assets/js/18.3f36e2e6.js"><link rel="prefetch" href="/assets/js/19.3c45229e.js"><link rel="prefetch" href="/assets/js/20.6d76ab7e.js"><link rel="prefetch" href="/assets/js/21.e287bb91.js"><link rel="prefetch" href="/assets/js/22.3ce20623.js"><link rel="prefetch" href="/assets/js/23.29a3e442.js"><link rel="prefetch" href="/assets/js/24.2ff10f7b.js"><link rel="prefetch" href="/assets/js/25.302f363a.js"><link rel="prefetch" href="/assets/js/26.385c96b0.js"><link rel="prefetch" href="/assets/js/27.a34112cc.js"><link rel="prefetch" href="/assets/js/28.2758b539.js"><link rel="prefetch" href="/assets/js/29.24fa6847.js"><link rel="prefetch" href="/assets/js/3.df3a87d4.js"><link rel="prefetch" href="/assets/js/30.b53bb299.js"><link rel="prefetch" href="/assets/js/31.953fbf0f.js"><link rel="prefetch" href="/assets/js/32.c7bb1c1f.js"><link rel="prefetch" href="/assets/js/33.5bbee94c.js"><link rel="prefetch" href="/assets/js/34.19e67de1.js"><link rel="prefetch" href="/assets/js/35.aab5dac9.js"><link rel="prefetch" href="/assets/js/37.4441c601.js"><link rel="prefetch" href="/assets/js/4.554dccb8.js"><link rel="prefetch" href="/assets/js/5.7ec69b64.js"><link rel="prefetch" href="/assets/js/6.fd22e7cc.js"><link rel="prefetch" href="/assets/js/7.55ca8e68.js"><link rel="prefetch" href="/assets/js/8.e401c731.js"><link rel="prefetch" href="/assets/js/9.6cc258f0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a4aa4dff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">前端笔记</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">前端笔记</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/browser/浏览器的进程与线程.html" class="sidebar-link">浏览器的进程与线程</a></li><li><a href="/notes/browser/浏览器的渲染原理.html" class="sidebar-link">浏览器的渲染原理</a></li><li><a href="/notes/browser/浏览器JS引擎.html" class="sidebar-link">浏览器JS引擎（V8）</a></li><li><a href="/notes/browser/浏览器EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/notes/browser/浏览器缓存策略.html" class="sidebar-link">浏览器缓存策略</a></li><li><a href="/notes/browser/跨域与页面通信.html" class="sidebar-link">跨域与页面通信</a></li><li><a href="/notes/browser/浏览器DOM事件与事件监听.html" class="sidebar-link">浏览器DOM事件与事件监听</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/network/网络知识.html" class="sidebar-link">网络知识</a></li><li><a href="/notes/network/Web安全.html" class="sidebar-link">Web安全 —— XSS 与 CSRF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/advanced/JS执行上下文栈.html" class="sidebar-link">JS执行上下文栈</a></li><li><a href="/notes/advanced/原型链与继承.html" class="sidebar-link">原型链继承</a></li><li><a href="/notes/advanced/Generator.html" class="sidebar-link">Generator</a></li><li><a href="/notes/advanced/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/notes/advanced/Proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/notes/advanced/节流和防抖.html" class="sidebar-link">函数的节流和防抖</a></li><li><a href="/notes/advanced/函数柯里化.html" class="sidebar-link">函数柯里化</a></li><li><a href="/notes/advanced/bind和call和apply.html" class="sidebar-link">bind-call-apply</a></li><li><a href="/notes/advanced/常见算法.html" class="sidebar-link">常见算法</a></li><li><a href="/notes/advanced/单例模式.html" class="sidebar-link">JavaScript 中单例设计模式的应用</a></li><li><a href="/notes/advanced/观察者模式.html" class="sidebar-link">观察者模式的简单实现</a></li><li><a href="/notes/advanced/使用setTimeout模拟setInterval.html" class="sidebar-link">封装一个 Timer 类，用 setTimeout 实现 setInterval</a></li><li><a href="/notes/advanced/new运算符.html" class="sidebar-link">JavaScript中的new运算符到底做了什么</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>其他知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/others/模块加载机制.html" class="sidebar-link">模块加载机制</a></li><li><a href="/notes/others/前端性能优化.html" class="sidebar-link">前端性能优化</a></li><li><a href="/notes/others/移动端适配方案.html" class="sidebar-link">移动端适配方案</a></li><li><a href="/notes/others/Vue与React的区别.html" class="sidebar-link">Vue与React的区别</a></li><li><a href="/notes/others/面试题整理.html" class="active sidebar-link">一些JS面试题整理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q1：输出以下代码的执行结果并解释为什么" class="sidebar-link">Q1：输出以下代码的执行结果并解释为什么</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q2：数组扁平化" class="sidebar-link">Q2：数组扁平化</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q3：-1-2-3-map-parseint-返回结果" class="sidebar-link">Q3：['1', '2', '3'].map(parseInt) 返回结果</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q4：" class="sidebar-link">Q4：[] == ![]</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q5-react中setstate在什么情况下是同步的？" class="sidebar-link">Q5: React中setState在什么情况下是同步的？</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q6-http2-0了解吗？" class="sidebar-link">Q6: HTTP2.0了解吗？</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q7-tcp连接的三次握手和四次挥手" class="sidebar-link">Q7: TCP连接的三次握手和四次挥手</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q8-https的握手流程" class="sidebar-link">Q8: HTTPS的握手流程</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q9-function-prototype-function-prototype" class="sidebar-link">Q9: Function[[prototype]] === Function.prototype?</a></li><li class="sidebar-sub-header"><a href="/notes/others/面试题整理.html#q10-为什么react的事件handler需要手动绑定this" class="sidebar-link">Q10: 为什么React的事件handler需要手动绑定this?</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>个人随笔</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/essay/给ReactRouter添加转场动画.html" class="sidebar-link">给React-Router添加路由页面切换时的过渡动画</a></li><li><a href="/notes/essay/Vue列表渲染中的key的作用.html" class="sidebar-link">key在Vue渲染列表时究竟起到了什么作用</a></li><li><a href="/notes/essay/vue源码阅读知识点整理.html" class="sidebar-link">Vue 源码阅读知识点整理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一些js面试题整理"><a href="#一些js面试题整理" class="header-anchor">#</a> 一些JS面试题整理</h1> <h2 id="q1：输出以下代码的执行结果并解释为什么"><a href="#q1：输出以下代码的执行结果并解释为什么" class="header-anchor">#</a> Q1：输出以下代码的执行结果并解释为什么</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span>

a<span class="token punctuation">.</span>x <span class="token comment">// --&gt; undefined</span>
b<span class="token punctuation">.</span>x <span class="token comment">// --&gt; {n: 2}</span>
</code></pre></div><h3 id="解析："><a href="#解析：" class="header-anchor">#</a> 解析：</h3> <p><strong>运算符优先级和连续赋值带来的坑</strong></p> <p>首先，<code>a</code>和<code>b</code>同时引用了<code>{n:2}</code>对象，接着执行到<code>a.x = a = {n：2}</code>语句，尽管赋值是从右到左的没错，但是<code>.</code>的优先级比<code>=</code>要高，所以这里首先执行<code>a.x</code>，相当于为<code>a</code>（或者<code>b</code>）所指向的<code>{n:1}</code>对象新增了一个属性x，即此时对象将变为<code>{n:1;x:undefined}</code>。</p> <p>之后按正常情况，从右到左进行赋值，此时执行<code>a ={n:2}</code>的时候，<code>a</code>的引用改变，指向了新对象<code>{n：2}</code>,而<code>b</code>依然指向的是旧对象。之后执行<code>a.x = {n：2}</code>的时候，并不会重新解析一遍<code>a</code>，而是沿用最初解析<code>a.x</code>时候的<code>a</code>，也即旧对象，故此时旧对象的<code>x</code>的值为<code>{n：2}</code>，旧对象为 <code>{n:1;x:{n：2}}</code>，它被<code>b</code>引用着。</p> <p>后面输出<code>a.x</code>的时候，又要解析<code>a</code>了，此时的<code>a</code>是指向新对象的<code>a</code>，而这个新对象是没有<code>x</code>属性的，故访问时输出<code>undefined</code>；而访问<code>b.x</code>的时候，将输出旧对象的<code>x</code>的值，即<code>{n:2}</code>。</p> <h2 id="q2：数组扁平化"><a href="#q2：数组扁平化" class="header-anchor">#</a> Q2：数组扁平化</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// [[1,2,2],[3, 4, 5, 5],[6, 7, 8, 9,[11,12,[12,13,[14]]]],10]  ------&gt;   [1,2,2,3,4,5,5,6,7,8,9,11,12,12,13,14,10]</span>

<span class="token comment">// 递归法  可使用reduce map for循环等实现</span>
<span class="token comment">// reduce</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// map</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// for</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span class="token comment">// 转字符串法 不过只适用于纯数字数组</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="q3：-1-2-3-map-parseint-返回结果"><a href="#q3：-1-2-3-map-parseint-返回结果" class="header-anchor">#</a> Q3：['1', '2', '3'].map(parseInt) 返回结果</h2> <h3 id="arrray-map"><a href="#arrray-map" class="header-anchor">#</a> Arrray.map</h3> <p><code>Array.map</code>方法会遍历原数组中的每个元素并执行<code>callback</code>，返回一个新的数组</p> <ul><li><code>callback</code>的第一个参数是<code>currentValue</code>，也就是原数组中正在处理的当前元素</li> <li><code>callback</code>的第二个参数是<code>index</code>，是原数组中正在处理的当前元素的索引</li></ul> <h3 id="parseint"><a href="#parseint" class="header-anchor">#</a> parseInt</h3> <p><code>parseInt</code>方法解析一个字符串参数，并返回一个指定基数（进制）的整数</p> <ul><li><code>parseInt</code>的第一个参数是<code>string</code>，也就是要被解析的字符串的值</li> <li><code>parseInt</code>得第二个参数是<code>radix</code>，一个介于2和36之间的整数，默认为10，代表解析字符串的基数（进制数）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
</code></pre></div><p>等同于</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>即返回值分别为</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</span>
</code></pre></div><p>所以</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
<span class="token comment">// 1, NaN, NaN</span>
</code></pre></div><h2 id="q4："><a href="#q4：" class="header-anchor">#</a> Q4：[] == ![]</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// true</span>
</code></pre></div><h3 id="解析：-2"><a href="#解析：-2" class="header-anchor">#</a> 解析：</h3> <p><code>==</code> 运算符，<code>javascript</code>语言灵活性的代表但也是最臭名昭著的黑魔法之一，比较运算之中发生的隐式类型转化不知坑了多少JSer。</p> <p>我们先来列举一下<code>==</code>（相等运算符）的运算规则</p> <ul><li>如果两个值类型相同，进行 <code>====</code> （严格相等运算符） 比较</li> <li>如果两个值类型不同，它们可能是相等的，此时根据下列规则进行类型转换后比较:
<ol><li>如果一个值为<code>null</code>，另一个是<code>undefined</code>，那么<strong>相等</strong></li> <li>如果一个值是<code>String</code>，另一个是<code>Number</code>，在比较之前要先将<code>String</code>转换为<code>Number</code>，即调用<code>Number()</code>方法</li> <li>如果一个值是<code>Boolean</code>，则先将这个<code>Boolean</code>转换为数值后再进行比较，即调用<code>Number()</code>方法</li> <li>如果一个值是<code>Object</code>，另一个是<code>String</code>或<code>Number</code>，则先将对象转换为基本数据类型再比较，即调用<code>javascript</code>内置类的<code>valueOf</code>或<code>toString</code>方法，<code>valueOf</code>会先于<code>toString</code>，例外的是<code>Date</code>对象，会直接用<code>toString</code>转换</li></ol></li></ul> <p>接下来我们分析一下<code>[] == ![]</code>为什么返回<code>true</code></p> <ol><li>首先运算符右边的<code>![]</code>会先进行运算，得到<code>false</code>，即<code>[] == false</code></li> <li>当等式两边有<code>Boolean</code>值得时候会先对其进行类型转换，即<code>Number(false) = 0</code>，等式两边变为<code>[] == 0</code></li> <li>当等式两边一个值为<code>Object</code>另一个为<code>Number</code>时，将<code>Object</code>进行类型转换，即<code>[].valueOf()</code>，发现返回的结果<code>[]</code>仍是<code>Object</code>，所以再调用<code>[].toString()</code>得到<code>''</code>，<code>Number('')</code>得到<code>0</code></li> <li><code>0 == 0</code> 成立， 返回<code>true</code></li></ol> <h2 id="q5-react中setstate在什么情况下是同步的？"><a href="#q5-react中setstate在什么情况下是同步的？" class="header-anchor">#</a> Q5: React中setState在什么情况下是同步的？</h2> <p>在 React 中，如果是在 React 引发的事件处理方法（比如通过 onClick 引发的事件处理）或在生命周期中调用 setState 不会同步更新 this.state 。除此之外的 setState 调用会同步执行this.state。所谓<strong>除此之外</strong>，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。</p> <blockquote><p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。  —— <a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener noreferrer">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <blockquote><p>setState 的<strong>异步</strong>并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</p></blockquote> <blockquote><p>setState 的批量更新优化也是建立在<strong>异步</strong>（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在<strong>异步</strong>中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p></blockquote> <p>关于setState的具体内容详见大佬的文章<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="noopener noreferrer">《你真的理解setState吗？》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="q6-http2-0了解吗？"><a href="#q6-http2-0了解吗？" class="header-anchor">#</a> Q6: HTTP2.0了解吗？</h2> <p>HTTP2.0新特性如下：</p> <ol><li><strong>新的二进制格式</strong>： HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li> <li><strong>多路复用</strong>：即连接共享，HTTP2.0多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行，HTTP1.x则可能会因为一个请求超时而发生线头阻塞。</li> <li><strong>header压缩</strong>：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li> <li><strong>服务端推送</strong>：服务端推送能把客户端所需要许多资源随着单次请求一起发送到客户端，省去了客户端重复请求的步骤</li></ol> <h2 id="q7-tcp连接的三次握手和四次挥手"><a href="#q7-tcp连接的三次握手和四次挥手" class="header-anchor">#</a> Q7: TCP连接的三次握手和四次挥手</h2> <h3 id="三次握手："><a href="#三次握手：" class="header-anchor">#</a> 三次握手：</h3> <p>客户端：我想和你建立连接</p> <p>服务端：ok，我现在可以和你建立连接</p> <p>客户端：好的，那我们现在开始连接吧</p> <h3 id="四次挥手："><a href="#四次挥手：" class="header-anchor">#</a> 四次挥手：</h3> <p>客户端：我准备断开连接了</p> <p>服务端：ok，但是我这边可能还有一些数据要传，等我传我我会通知你</p> <p>服务端：我传完了，可以断开连接了</p> <p>客户端：ok，你断开连接吧</p> <p>（服务端：收到客户端最后一次信息后断开连接，未收到就会要求客户端重新发送关闭信息）</p> <p>（客户端：发送最后一次信息后等待2MLS(2倍报文最大生存时间)，没有收到服务端的重传请求就关闭自己的连接）</p> <h3 id="三次握手具体操作："><a href="#三次握手具体操作：" class="header-anchor">#</a> 三次握手具体操作：</h3> <ul><li><p>第一次握手：客户端发送一个TCP标志位SYN=1，ACK=0的数据包给服务端，并随机会产生一个Sequence number=3233.当服务端接收到这个数据后，服务端由SYN=1可知客户端是想要建立连接；</p></li> <li><p>第二次握手：服务端要对客户端的联机请求进行确认，向客户端发送应答号ACK=1、SYN=1
确认号Acknowledge number=3234，此值是客户端的序列号加1，还会产生一个随机的序列号Sequence number=36457，这样就告诉客户端可以进行连接；</p></li> <li><p>第三次握手：客户端收到数据后检查Acknowledge number是否是3233+1的值，以及ACK的值是否为1，若为1，host1会发送ACK=1、确认号码Acknowledge number=36457，告诉服务端,你的请求连接被确认，连接可以建立。</p></li></ul> <h3 id="四次挥手具体操作："><a href="#四次挥手具体操作：" class="header-anchor">#</a> 四次挥手具体操作：</h3> <ul><li><p>第一次挥手：当传输的数据到达尾部时，客户端向服务端发送FIN=1标志位；可理解成，客户端向服务端说，我这边的数据传送完成了，我准备断开了连接；</p></li> <li><p>第二次挥手：因TCP的连接是全双工的双向连接，关闭也是要从两边关闭；当服务端收到客户端发来的FIN=1的标志位后，服务端不会立刻向客户端发送FIND=1的请求关闭信息，
而是先向客户端发送一个ACK=1的应答信息，表示：你请求关闭的请求我已经收到，但我可能还有数据没有完成传送，你再等下，等我数据传输完成了我就告诉你；</p></li> <li><p>第三次挥手：服务端数据传输完成，向客户端发送FIN=1，客户端收到请求关闭连接的请求后，客户端就明白服务端的数据已传输完成，现在可以断开连接了，</p></li> <li><p>第四次挥手：客户端收到FIND=1后，客户端还是怕由于网络不稳定的原因，怕服务端不知道他要断开连接，于是向服务端发送ACK=1确认信息进行确认，
把自己设置成TIME_WAIT状态并启动定时器，如果服务端没有收到ACK，服务端TCP的定时器到达后，会要求客户端重新发送ACK，当服务端收到ACK后，服务端就断开连接；
当客户端等待2MLS（2倍报文最大生存时间）后，没有收到服务端的重传请求后，他就知道服务端已收到了ACK，所以客户端此时才关闭自己的连接。</p></li></ul> <h2 id="q8-https的握手流程"><a href="#q8-https的握手流程" class="header-anchor">#</a> Q8: HTTPS的握手流程</h2> <ol><li><p>浏览器给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</p></li> <li><p>web服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</p></li> <li><p>浏览器确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给web服务器。</p></li> <li><p>web服务器使用自己的私钥，获取浏览器发来的随机数（即Premaster secret）。</p></li> <li><p>浏览器和web服务器根据约定的加密方法，使用前面的三个随机数，生成&quot;对话密钥&quot;（session key），用来加密接下来的整个对话过程。</p></li></ol> <h2 id="q9-function-prototype-function-prototype"><a href="#q9-function-prototype-function-prototype" class="header-anchor">#</a> Q9: Function[[prototype]] === Function.prototype?</h2> <p>是对的  因为 Function 也是一个函数，它的__proto__指向 Function 构造函数的原型，很扯</p> <p>应该是现有 Function.prototype 然后有的 function Function()</p> <h2 id="q10-为什么react的事件handler需要手动绑定this"><a href="#q10-为什么react的事件handler需要手动绑定this" class="header-anchor">#</a> Q10: 为什么React的事件handler需要手动绑定this?</h2> <p>相对于其他框架来说，react使用了合成事件（SyntheticEvent）来标准化浏览器的事件。</p> <p>合成事件是一种顶层代理机制，这种代理机制作用的结果是：</p> <blockquote><p>事件依然在真实的dom节点上触发，之后会冒泡一路到document的节点，然后开始分发document节点收集到的事件，这个时候react从事件触发的组件实例开始， 遍历虚拟dom树，从树上取下我们绑定的事件，收集起来，然后执行。</p></blockquote> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
   <span class="token function-variable function">fatherHandler</span> <span class="token operator">=</span>  <span class="token keyword">function</span> <span class="token function">father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span><span class="token punctuation">}</span>
   <span class="token function-variable function">childHander</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span>
       <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fatherHandler<span class="token punctuation">}</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>span onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>childHander<span class="token punctuation">}</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当事件触发以后react会把上面的事件处理函数放到一个数组里是这样的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>father<span class="token punctuation">,</span> child<span class="token punctuation">]</span>
</code></pre></div><p>最后，react只要遍历执行这个数组，就能执行所有需要执行的事件处理函数。哈哈，想必眼尖的同学已经看出问题了，之前我们对函数进行了临时保存(简单粗暴的把事件处理函数赋值给了onClick属性)，这个时候执行的话，this自然就丢失了。有的同学也说了这其实不是react的锅，是js本身的问题。但是如果react保存顺便保存一下实例，还是可以做到，不需要你绑定this的，但是这样对于react来说代价太大了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">{</span>instance<span class="token punctuation">,</span> father<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>instance，child<span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/others/Vue与React的区别.html" class="prev">Vue与React的区别</a></span> <span class="next"><a href="/notes/essay/给ReactRouter添加转场动画.html">给React-Router添加路由页面切换时的过渡动画</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a0ed42a3.js" defer></script><script src="/assets/js/2.ddf9653e.js" defer></script><script src="/assets/js/36.3b360b27.js" defer></script>
  </body>
</html>
