<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 源码阅读知识点整理 | 学习笔记</title>
    <meta name="description" content="构建自己的前端知识体系">
    
    
    <link rel="preload" href="/assets/css/0.styles.a4aa4dff.css" as="style"><link rel="preload" href="/assets/js/app.84f5df7b.js" as="script"><link rel="preload" href="/assets/js/2.ddf9653e.js" as="script"><link rel="preload" href="/assets/js/22.01f8765e.js" as="script"><link rel="prefetch" href="/assets/js/10.ccf87d42.js"><link rel="prefetch" href="/assets/js/11.a53db162.js"><link rel="prefetch" href="/assets/js/12.64cedf27.js"><link rel="prefetch" href="/assets/js/13.b535b9cf.js"><link rel="prefetch" href="/assets/js/14.c83bc5cc.js"><link rel="prefetch" href="/assets/js/15.1d591647.js"><link rel="prefetch" href="/assets/js/16.8b4337e1.js"><link rel="prefetch" href="/assets/js/17.46a5b6d8.js"><link rel="prefetch" href="/assets/js/18.2ccb0372.js"><link rel="prefetch" href="/assets/js/19.3f57e8de.js"><link rel="prefetch" href="/assets/js/20.f3c3e2a8.js"><link rel="prefetch" href="/assets/js/21.8baedc69.js"><link rel="prefetch" href="/assets/js/23.0e10acaa.js"><link rel="prefetch" href="/assets/js/24.21fe77b5.js"><link rel="prefetch" href="/assets/js/25.d1149e9e.js"><link rel="prefetch" href="/assets/js/26.b0b546d6.js"><link rel="prefetch" href="/assets/js/27.be067827.js"><link rel="prefetch" href="/assets/js/28.dfb2fa3a.js"><link rel="prefetch" href="/assets/js/29.f2384621.js"><link rel="prefetch" href="/assets/js/3.62ae8627.js"><link rel="prefetch" href="/assets/js/30.f7e309d4.js"><link rel="prefetch" href="/assets/js/4.554dccb8.js"><link rel="prefetch" href="/assets/js/5.8372670c.js"><link rel="prefetch" href="/assets/js/6.fd22e7cc.js"><link rel="prefetch" href="/assets/js/7.55ca8e68.js"><link rel="prefetch" href="/assets/js/8.e401c731.js"><link rel="prefetch" href="/assets/js/9.6cc258f0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a4aa4dff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">笔记</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">笔记</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/browser/浏览器的进程与线程.html" class="sidebar-link">浏览器的进程与线程</a></li><li><a href="/notes/browser/浏览器的渲染原理.html" class="sidebar-link">浏览器的渲染原理</a></li><li><a href="/notes/browser/浏览器JS引擎.html" class="sidebar-link">浏览器JS引擎（V8）</a></li><li><a href="/notes/browser/浏览器EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/notes/browser/浏览器缓存策略.html" class="sidebar-link">浏览器缓存策略</a></li><li><a href="/notes/browser/跨域与页面通信.html" class="sidebar-link">跨域与页面通信</a></li><li><a href="/notes/browser/浏览器DOM事件与事件监听.html" class="sidebar-link">浏览器DOM事件与事件监听</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/network/网络知识.html" class="sidebar-link">网络知识</a></li><li><a href="/notes/network/Web安全.html" class="sidebar-link">Web安全 —— XSS 与 CSRF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/advanced/JS执行上下文栈.html" class="sidebar-link">JS执行上下文栈</a></li><li><a href="/notes/advanced/原型链与继承.html" class="sidebar-link">原型链继承</a></li><li><a href="/notes/advanced/Generator.html" class="sidebar-link">Generator</a></li><li><a href="/notes/advanced/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/notes/advanced/Proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/notes/advanced/节流和防抖.html" class="sidebar-link">函数的节流和防抖</a></li><li><a href="/notes/advanced/函数柯里化.html" class="sidebar-link">函数柯里化</a></li><li><a href="/notes/advanced/bind和call和apply.html" class="sidebar-link">bind-call-apply</a></li><li><a href="/notes/advanced/常见算法.html" class="sidebar-link">常见算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/others/模块加载机制.html" class="sidebar-link">模块加载机制</a></li><li><a href="/notes/others/前端性能优化.html" class="sidebar-link">前端性能优化</a></li><li><a href="/notes/others/移动端适配方案.html" class="sidebar-link">移动端适配方案</a></li><li><a href="/notes/others/Vue与React的区别.html" class="sidebar-link">Vue与React的区别</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>个人随笔</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/essay/vue源码阅读知识点整理.html" class="active sidebar-link">Vue 源码阅读知识点整理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#vue-首次渲染流程" class="sidebar-link">Vue 首次渲染流程</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#为什么全局注册组件在哪里都能用（全局指令，全局过滤器同理）" class="sidebar-link">为什么全局注册组件在哪里都能用（全局指令，全局过滤器同理）</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#依赖收集的流程" class="sidebar-link">依赖收集的流程</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#派发更新的流程" class="sidebar-link">派发更新的流程</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#nexttick-实现" class="sidebar-link">nextTick 实现</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#computed-实现原理" class="sidebar-link">computed 实现原理</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#watch-实现原理" class="sidebar-link">watch 实现原理</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#组件更新流程" class="sidebar-link">组件更新流程</a></li><li class="sidebar-sub-header"><a href="/notes/essay/vue源码阅读知识点整理.html#compile流程" class="sidebar-link">compile流程</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-源码阅读知识点整理"><a href="#vue-源码阅读知识点整理" class="header-anchor">#</a> Vue 源码阅读知识点整理</h1> <h2 id="vue-首次渲染流程"><a href="#vue-首次渲染流程" class="header-anchor">#</a> Vue 首次渲染流程</h2> <ol><li><p>new Vue 触发第一次_init 调用 beforeCreate 和 created hook</p></li> <li><p>触发根组件的$mount</p></li> <li><p>触发 mountComponent 调用 beforeMount hook</p></li> <li><p>触发_update</p></li> <li><p>先执行 vm._render 拿到根组件 vnode 树（render 会调用组件的 render 方法通过 createElement 方法创建 vnode，在创建根组件的子组件 vnode 的时候(即 createCompoent 方法) 生成子组件构造器 并 注册 vnode 的 init 钩子）</p></li> <li><p>创建渲染 watcher 渲染 watcher 自执行一次 执行_update（并在此设置 activeInstance） 触发 patch 并注册 beforeUpdate 钩子</p></li> <li><p>执行 patch 调用 createElm</p></li> <li><p>执行 createElm 如果是组件就触发 createComponent(createElm 内部的) 触发 init 钩子</p></li> <li><p>init 钩子中 new 一个子组件的构造器</p></li> <li><p>触发子组件的_init 在此时绑定父子关系</p></li> <li><p>触发子组件的$mount，然后触发 createComponent 后续的 insert</p></li> <li><p>。。。递归到最深层的组件</p></li> <li><p>createElm 会执行 insert 将真实 dom 节点插入父节点 然后 patch 调用 vnode 的 insert 钩子 然后 insert 中执行 mounted hook （mounted 是先子后父，因为子组件先 insert 完成）</p></li> <li><p>真实的 DOM 树会在递归完成时一级一级向上插入，最后插入到 body 上</p></li></ol> <h2 id="为什么全局注册组件在哪里都能用（全局指令，全局过滤器同理）"><a href="#为什么全局注册组件在哪里都能用（全局指令，全局过滤器同理）" class="header-anchor">#</a> 为什么全局注册组件在哪里都能用（全局指令，全局过滤器同理）</h2> <p>因为全局注册组件合并到了 Vue.options 上，而所有的子组件的$options 对象都能通过原型链访问到 Vue.options</p> <p>而局部注册的组件合并到了 Sub.options 上 也就是它的父组件上</p> <p>具体可以看 _init 中的 initInternalComponent 方法中的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> opts <span class="token operator">=</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>options<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="依赖收集的流程"><a href="#依赖收集的流程" class="header-anchor">#</a> 依赖收集的流程</h2> <ol><li><p>initState 对 props data 等递归进行 observe(obj), obeserve 调用 new Observe 并将实例赋值给 obj 的不可枚举属性<strong>ob</strong>，Observe 构造函数中执行 walk 或 observeArray 递归调用 defineReactive</p></li> <li><p>defineReactive 中会首先 new Dep 对应这个响应对象，然后定义对象 get 方法</p></li> <li><p>initState 之后挂载的时候调用 mountComponent 方法</p></li> <li><p>mountComponent 会新建一个渲染 watcher new Watcher 的过程中调用构造函数，构造函数最后执行 get 方法 然后 pushTarget 然后 Dep.target 就变成当前渲染 watcher 然后执行_update(之前当做 getter 传入了 watcher 的构造函数)</p></li> <li><p>执行_update 首先要执行_render 这个过程中就访问了响应对象，调用了他们的 get 方法</p></li> <li><p>当 get 执行的时候就会执行 dep.depend，然后当前的 Watcher(即 Dep.target)执行 addDep，此时 dep.sub 中添加了 Watcher，Watcher 中的 newDeps newDepIds 也添加了 dep</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// dep.js</span>
<span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// watcher.js</span>
<span class="token function">addDep</span> <span class="token punctuation">(</span><span class="token parameter">dep<span class="token operator">:</span> Dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> dep<span class="token punctuation">.</span>id
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>depIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>当前渲染 watcher 的依赖收集完毕，然后 popTarget 回到上一个 watcher（因为_update 是递归的，所以有一个 targetStack 栈保存 Dep.target）</p></li> <li><p>执行 cleanupDeps 把上一次 render 中添加的(newDepIds 中添加了 id 的 dep)但在这一次 render 中并没有添加的 dep 给清除掉（清除的是 dep.subs 中的 watcher）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>dep<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dep<span class="token punctuation">.</span><span class="token function">removeSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h2 id="派发更新的流程"><a href="#派发更新的流程" class="header-anchor">#</a> 派发更新的流程</h2> <ol><li><p>触发 响应对象的 setter 调用 dep.notify 然后触发 subs 中所有 watcher 的 update</p></li> <li><p>执行 queueWatcher 添加进 queue，然后再 nextTick 中执行 flushSchedulerQueue，这个方法执行会把 flushing 这个变量变为 true。</p> <p>注意：此时 queueWatcher 不会直接 queue.push 而是会找到第一个待插入 watcher 的 id 比 queue 中 watcher 的 id 大的位置，把 watcher 按照 id 插入到 queue 中</p></li> <li><p>flushSchedulerQueue 会先对 queue 进行排序，然后遍历 watcher 执行 watcher.before(beforeUpdate 钩子) 然后执行 watcher.run</p> <div class="language-js extra-class"><pre class="language-js"><code>queue<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>id <span class="token operator">-</span> b<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>排序的作用：</p> <ol><li><p>组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。</p></li> <li><p>用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。</p></li> <li><p>如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。</p></li></ol> <p>在 watcher.run() 的时候，很可能用户会再次添加新的 watcher，这样会再次执行到 queueWatcher，然后 queue 的长度发生变化，然后遍历的 watcher 就会变多。如果检测到新加入的 watcher 已经存在于未遍历的数组中，则触发无限循环更新的报错（比如在 watch 的 cb 里修改被 watch 的变量的值）</p></li> <li><p>watcher.run 执行 get 方法 即 pushTarget getter(updateComponent) popTarget 等操作，触发组件的重新渲染，并在重新渲染过程中 重新进行依赖收集</p></li> <li><p>watcher 遍历完毕之后 执行 resetSchedulerState 重置 queue 和 flushing waiting 等，然后调用 activated 和 updated 钩子</p></li></ol> <h2 id="nexttick-实现"><a href="#nexttick-实现" class="header-anchor">#</a> nextTick 实现</h2> <ol><li><p>维护一个 callbacks 数组</p></li> <li><p>定义一个 flushCallbacks，拷贝 callbacks 清空 callbacks 后遍历执拷贝得来的 callbacks</p></li> <li><p>定义一个 timerFunc，将 flushCallbacks 进行异步化</p> <p>timerFunc 的优先级分别为</p> <ol><li>Promise.then</li> <li>MutationObserver(之前还用过 MessageChannel)<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  characterData<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>
  textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>setImmediate</li> <li>setTimeout(flushCallbacks, 0)</li></ol></li> <li><p>定义 nextTick 每次执行都会给 callbacks 数组中添加 cb，如果这次执行没有传 cb 的话就返回一个 Promise 用来支持.then 链式调用，然后向 callbacks 中 push 这个 Promise 的 resolve</p></li></ol> <h2 id="computed-实现原理"><a href="#computed-实现原理" class="header-anchor">#</a> computed 实现原理</h2> <ol><li><p>执行 initComputed 创建一个 computed watcher 执行 definedComputed(这一步在创建 Sub 构造器的时候已经执行了，所以 computed key 被挂载到了 vm 的原型上)</p></li> <li><p>definedComputed 会给 这个 computed key 添加数据监听，get 方法为 createComputedGetter</p></li> <li><p>createComputedGetter 中会取到 key 对应的 watcher 然后执行 watcher 的 evaluate 方法（如果 dirty 为 true，即依赖没发生改变才重新 evaluate），就是执行 watcher.get 然后 pushTarget 执行 getter popTarget 完成依赖收集，不过这里的 getter 不同于渲染 watcher 不是 updateComponent 了，而是求值然后，然后又将这些依赖添加到了渲染 watcher（ 或者上一层的computed watcher ） 中，保证每次 computed 值变化就触发重新渲染</p></li> <li><p>当响应对象 set 之后，会触发 dep.notify 这时候就会使该 dep.subs 下的 computed watcher 更新 将 watcher.dirty 变为 true，下次 get 重新计算</p></li></ol> <h2 id="watch-实现原理"><a href="#watch-实现原理" class="header-anchor">#</a> watch 实现原理</h2> <p>其实就是创建一个一个 user watcher ，与其它 watcher 不同的地方在于可以传 cb 和 options(如 deep sync immediate 等) 然后这个地方的 getter 会被处理成一个响应对象的属性名（嵌套属性用 parsePath 处理成数组）</p> <p>new Watcher 最后 执行 get 方法时，getter 就是访问定义的响应对象，然后就完成了依赖收集</p> <p>如果 options deep 为 true 就在 get 中执行 traverse 把深层对象的所有值全访问一遍收集依赖
如果 options sync 为 true 则不进入 queueWatcher，直接同步执行 watcher.run
如果 options immediate 为 true 则在执行$watch 的时候，在 new Watcher 之后就直接执行一遍 cb</p> <h2 id="组件更新流程"><a href="#组件更新流程" class="header-anchor">#</a> 组件更新流程</h2> <ol><li><p>patch 方法中，如果 oldVnode 和 vnode 都存在，则判断是否为 sameVnode</p></li> <li><p>如果是的话 进入 patchVnode，不是的话 执行 createElm，生成新的 DOM 节点并插入，然后更新 ancestor.elm(用新创建的 DOM 节点更新父的占位符节点下的真实 DOM 节点)，删除旧的 DOM 节点</p></li> <li><p>接上文，如果是的话，执行 patchVnode，如果 vnode 是组件 vnode，则先执行 prepatch 钩子更新组件的 attr props listners 等</p></li> <li><p>如果 vnode.text 不存在，也就是说不是文本节点，则有以下几种情况，见代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">!==</span> ch<span class="token punctuation">)</span>
      <span class="token function">updateChildren</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&quot;production&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">checkDuplicateKeys</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">addVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ch<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">removeVnodes</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中 updateChildren 中又会递归执行patchVnode，更新整棵组件DOM树</p> <p>updateChildren 对oldVnode和vnode进行头尾交叉对比，然后根据对比情况采取不同的逻辑变更真实的DOM，如果头尾交叉对比没结果，就根据key来</p></li> <li><p>不然就更新 vnode.text</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>组件vnode patch 完毕之后会再执行一次prepatch钩子</p></li></ol> <h2 id="compile流程"><a href="#compile流程" class="header-anchor">#</a> compile流程</h2> <ol><li><p>createCompilerCreator传入baseCompile方法，返回createCompiler方法</p></li> <li><p>createCompiler传入平台baseOptions 返回compile方法和compileToFunctions方法</p></li> <li><p>一连串的执行后我们执行编译核心方法baseCompile</p></li> <li><p>先parse生成AST</p> <p>parseHTML，advance不停地切割template，过程中判断标签，收集attrs，加入stack中</p> <p>parseStartTag后赋值给startTagMatch 如果startTagMatch为 true 执行handleStartTag，handleStartTag最后执行options.start，生成ASTelement，处理attrs（比如各种process方法，给ASTelement添加属性），根据stack确定闭合状态和进行AST管理（确立父子关系）</p> <p>ASTelm type有三种  1是普通ast 2是表单式如{{}} 3是文本ast</p> <p>endTagMatch如果为true 执行parseEndTag 执行options.end 更新stack 执行closeElement</p></li> <li><p>optimize优化AST  递归对AST进行markStatic 和 markStaticRoot 静态优化 staticRoot如果子节点是纯文本节点且长度为1则为false</p></li> <li><p>generate生成render函数</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/others/Vue与React的区别.html" class="prev">Vue与React的区别</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.84f5df7b.js" defer></script><script src="/assets/js/2.ddf9653e.js" defer></script><script src="/assets/js/22.01f8765e.js" defer></script>
  </body>
</html>
