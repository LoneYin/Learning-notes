(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{233:function(_,v,e){"use strict";e.r(v);var t=e(0),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"tcp协议与dns协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议与dns协议"}},[_._v("#")]),_._v(" TCP协议与DNS协议")]),_._v(" "),e("h2",{attrs:{id:"网络分层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络分层"}},[_._v("#")]),_._v(" 网络分层")]),_._v(" "),e("ul",[e("li",[_._v("物理层")]),_._v(" "),e("li",[_._v("数据链路层 (以太网)")]),_._v(" "),e("li",[_._v("网络层（IP）")]),_._v(" "),e("li",[_._v("传输层（TCP UDP)")]),_._v(" "),e("li",[_._v("会话层 (RPC，SQL，NFS，NetBIOS，names，AppleTalk)")]),_._v(" "),e("li",[_._v("表示层 (TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption)")]),_._v(" "),e("li",[_._v("应用层（HTTP, DNS, FTP, SMTP(邮件)）")])]),_._v(" "),e("h3",{attrs:{id:"tcp-udp-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp-的区别"}},[_._v("#")]),_._v(" TCP/UDP 的区别")]),_._v(" "),e("img",{attrs:{src:"/Learning-notes/img/tcp-udp.jpg"}}),_._v(" "),e("h2",{attrs:{id:"tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[_._v("#")]),_._v(" TCP")]),_._v(" "),e("h3",{attrs:{id:"tcp-协议的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议的特点"}},[_._v("#")]),_._v(" TCP 协议的特点")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("面向连接")]),_._v(" "),e("p",[_._v("面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。")])]),_._v(" "),e("li",[e("p",[_._v("仅支持单播传输")]),_._v(" "),e("p",[_._v("每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。")])]),_._v(" "),e("li",[e("p",[_._v("面向字节流")]),_._v(" "),e("p",[_._v("TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。")])]),_._v(" "),e("li",[e("p",[_._v("可靠传输")]),_._v(" "),e("p",[_._v("对于可靠传输，判断丢包，误码靠的是 TCP 的序列号(Sequence Number)以及确认号(Acknowledgment Number)。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。")])]),_._v(" "),e("li",[e("p",[_._v("提供拥塞控制")]),_._v(" "),e("p",[_._v("当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞")])]),_._v(" "),e("li",[e("p",[_._v("TCP 提供全双工通信")]),_._v(" "),e("p",[_._v("TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）")])])]),_._v(" "),e("h3",{attrs:{id:"rtt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rtt"}},[_._v("#")]),_._v(" RTT")]),_._v(" "),e("p",[_._v("RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。")]),_._v(" "),e("p",[_._v("RTT = 传播时延（往返）+ 排队时延（路由器和交换机的）+ 数据处理时延（应用程序的）")]),_._v(" "),e("h3",{attrs:{id:"tcp-超时重传"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-超时重传"}},[_._v("#")]),_._v(" TCP 超时重传")]),_._v(" "),e("p",[_._v("超时重传是TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。")]),_._v(" "),e("h3",{attrs:{id:"tcp-三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手"}},[_._v("#")]),_._v(" TCP 三次握手")]),_._v(" "),e("blockquote",[e("p",[_._v("张三首先向李四招手(SYN)")])]),_._v(" "),e("blockquote",[e("p",[_._v("李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ACK)并招手(SYN)，这里其实是两步合成了一步")])]),_._v(" "),e("blockquote",[e("p",[_._v("张三看到李四招手后也点头微笑（ACK）")])]),_._v(" "),e("p",[_._v("第一次握手： 建立连接。客户端发送连接请求报文段，将 SYN 标志位设置为 1，ACK 标志位设置为0， Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务端的确认；")]),_._v(" "),e("p",[_._v("第二次握手： 服务端收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x + 1(Sequence Number + 1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 标志位设置为 1，ACK 标志位设置为 1（建立连接后ACK标志位都为1），Sequence Number 为 y ；服务端将上述所有信息放到一个报文段（即 SYN + ACK 报文段）中，一并发送给客户端，此时服务端进入 SYN_RECV 状态；")]),_._v(" "),e("p",[_._v("第三次握手： 客户端收到服务端的 SYN + ACK 报文段。然后将 Acknowledgment Number 设置为 y + 1，向服务端发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务端都进入 ESTABLISHED 状态，完成 TCP 三次握手。")]),_._v(" "),e("p",[_._v("为什么要三次握手？")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，因为服务端如果不经过第三次握手的确认，就会误以为客户端发起了新的连接请求，而客服端实际上没有，服务端发出确认报文段后就会认为新的连接已经建立，等待客户端根本不会发来的“数据”，白白浪费资源。")])]),_._v(" "),e("li",[e("p",[_._v("因此 TCP 要保证数据的可靠传输，如果只发生一、二两次握手的话，那么服务端就不能确认客户端是否接收到了它发送的 SYN + ACK 报文段，可靠连接的确认是要双向的，两端必须都发送 ACK 报文段才能保证两端都具备正常的收发能力。")])])]),_._v(" "),e("h3",{attrs:{id:"tcp-四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[_._v("#")]),_._v(" TCP 四次挥手")]),_._v(" "),e("blockquote",[e("p",[_._v("张三挥手(FIN)")])]),_._v(" "),e("blockquote",[e("p",[_._v("李四伤感地微笑(ACK)，但表示还有几句话想说（所以这里没有发生步骤合并）")])]),_._v(" "),e("blockquote",[e("p",[_._v("李四把话说完后挥手(FIN)")])]),_._v(" "),e("blockquote",[e("p",[_._v("张三伤感地微笑(ACK)，看到李四离去(closed)")])]),_._v(" "),e("blockquote",[e("p",[_._v("张三注视着李四背影消失(time_wait)，等待了一会儿(2MSL)，然后自己也离去了(closed)")])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("第一次挥手： "),e("code",[_._v("主机1")]),_._v("（可以使客户端，也可以是服务端），设置 Sequence Number 为 x，向"),e("code",[_._v("主机2")]),_._v("发送一个 FIN 报文段；此时，"),e("code",[_._v("主机1")]),_._v("进入 FIN_WAIT_1 状态；这表示"),e("code",[_._v("主机1")]),_._v("没有数据要发送给"),e("code",[_._v("主机2")]),_._v("了；")])]),_._v(" "),e("li",[e("p",[_._v("第二次挥手： "),e("code",[_._v("主机2")]),_._v("收到了"),e("code",[_._v("主机1")]),_._v("发送的 FIN 报文段，向"),e("code",[_._v("主机1")]),_._v("回一个 ACK 报文段，Acknowledgment Number 为 x + 1；"),e("code",[_._v("主机1")]),_._v("进入 FIN_WAIT_2 状态；"),e("code",[_._v("主机2")]),_._v("告诉"),e("code",[_._v("主机1")]),_._v("，我同意你的关闭请求，但我可能还有一些东西要传，传完之后我会告诉你；")])]),_._v(" "),e("li",[e("p",[_._v("第三次挥手： "),e("code",[_._v("主机2")]),_._v("向"),e("code",[_._v("主机1")]),_._v("发送 FIN 报文段，请求关闭连接，同时"),e("code",[_._v("主机2")]),_._v("进入 LAST_ACK 状态；")])]),_._v(" "),e("li",[e("p",[_._v("第四次挥手： "),e("code",[_._v("主机1")]),_._v("收到"),e("code",[_._v("主机2")]),_._v("发送的 FIN 报文段，向"),e("code",[_._v("主机2")]),_._v("发送 ACK 报文段，然后"),e("code",[_._v("主机1")]),_._v("进入 TIME_WAIT 状态；"),e("code",[_._v("主机2")]),_._v("收到"),e("code",[_._v("主机1")]),_._v("的 ACK 报文段以后，就关闭连接；此时，"),e("code",[_._v("主机1")]),_._v("等待 2MSL 后依然没有收到回复，则证明"),e("code",[_._v("主机2")]),_._v("已正常关闭，此时"),e("code",[_._v("主机1")]),_._v("也可以关闭连接了。")])])]),_._v(" "),e("p",[_._v("为什么要四次挥手？")]),_._v(" "),e("p",[_._v("当"),e("code",[_._v("主机1")]),_._v("发出 FIN 报文段时，只是表示"),e("code",[_._v("主机1")]),_._v("已经没有数据要发送了；但是，这个时候"),e("code",[_._v("主机1")]),_._v("还是可以接受来自"),e("code",[_._v("主机2")]),_._v("的数据；当"),e("code",[_._v("主机2")]),_._v("返回 ACK 报文段时，表示它已经知道"),e("code",[_._v("主机1")]),_._v("没有数据发送了，但是"),e("code",[_._v("主机2")]),_._v("还是可以发送数据到"),e("code",[_._v("主机1")]),_._v("的；当"),e("code",[_._v("主机2")]),_._v("也发送了 FIN 报文段时，这个时候就表示"),e("code",[_._v("主机2")]),_._v("也没有数据要发送了，就会告诉"),e("code",[_._v("主机1")]),_._v("，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。")]),_._v(" "),e("h3",{attrs:{id:"tcp-滑动窗口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-滑动窗口"}},[_._v("#")]),_._v(" TCP 滑动窗口")]),_._v(" "),e("p",[_._v("在 TCP 中，两端其实都维护着窗口：分别为发送端窗口和接收端窗口。")]),_._v(" "),e("p",[_._v("发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据，窗口之外就是已经应答和不能发送的数据。")]),_._v(" "),e("p",[_._v("发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。")]),_._v(" "),e("p",[_._v("当发送端接收到应答报文后，会随之将窗口进行滑动，原本不能发送的数据会进入窗口。")]),_._v(" "),e("p",[_._v("接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况。")]),_._v(" "),e("p",[_._v("滑动窗口解决了数据的丢包、顺序不对（丢包会重传，确认后窗口才会滑动）和流量控制问题")]),_._v(" "),e("h3",{attrs:{id:"tcp-拥塞控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-拥塞控制"}},[_._v("#")]),_._v(" TCP 拥塞控制")]),_._v(" "),e("p",[_._v("TCP 维护一个拥塞窗口cwnd（congestion window），用来估计在一段时间内这条链路可以承载和运输的数据的数量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化")]),_._v(" "),e("p",[_._v("关于拥塞控制的 Reno 算法：")]),_._v(" "),e("h4",{attrs:{id:"慢开始"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#慢开始"}},[_._v("#")]),_._v(" 慢开始")]),_._v(" "),e("p",[_._v("慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段")]),_._v(" "),e("h4",{attrs:{id:"拥塞避免"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免"}},[_._v("#")]),_._v(" 拥塞避免")]),_._v(" "),e("p",[_._v("当窗口达到慢启动阈值或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段")]),_._v(" "),e("h4",{attrs:{id:"快重传"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快重传"}},[_._v("#")]),_._v(" 快重传")]),_._v(" "),e("p",[_._v("快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认")]),_._v(" "),e("h4",{attrs:{id:"快恢复"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快恢复"}},[_._v("#")]),_._v(" 快恢复")]),_._v(" "),e("p",[_._v("快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程")]),_._v(" "),e("h2",{attrs:{id:"dns"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns"}},[_._v("#")]),_._v(" DNS")]),_._v(" "),e("p",[_._v("DNS (Domain Name System)， 也叫网域名称系统，是互联网的一项服务。它实质上是一个 域名 和 IP 相互映射的分布式数据库，有了它，我们就可以通过域名更方便的访问互联网。")]),_._v(" "),e("p",[_._v("DNS服务 使用 UDP 协议发送查询请求。")]),_._v(" "),e("h3",{attrs:{id:"域名级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#域名级别"}},[_._v("#")]),_._v(" 域名级别")]),_._v(" "),e("p",[_._v("域名级别是网址分类的一个标准，包括顶级域名、二级域名等。一个完整的域名由二个或二个以上部分组成，各部分之间用英文的句号"),e("code",[_._v(".")]),_._v("来分隔，倒数第一个"),e("code",[_._v(".")]),_._v("的右边部分称为顶级域名（TLD，也称为一级域名，包含一个合法字符串，和一个域名后缀），顶级域名的左边部分字符串到下个"),e("code",[_._v(".")]),_._v("为止称为二级域名（SLD），二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。所有域名后面其实都有一个隐藏的"),e("code",[_._v(".")]),_._v("，代表根域名。")]),_._v(" "),e("p",[_._v("拿 "),e("code",[_._v("www.baidu.com")]),_._v(" 来说  顶级域名com 二级域名baidu 三级域名www")]),_._v(" "),e("h3",{attrs:{id:"dns解析流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns解析流程"}},[_._v("#")]),_._v(" DNS解析流程")]),_._v(" "),e("p",[_._v("默认是先查找hosts文件，如果没有匹配到，再进行DNS解析")]),_._v(" "),e("ol",[e("li",[_._v("客户端向本地DNS服务器(递归解析服务器) 发出解析 "),e("code",[_._v("www.baidu.com")]),_._v(" 域名的请求")]),_._v(" "),e("li",[_._v("本地DNS服务器查看缓存，是否有缓存过 "),e("code",[_._v("www.baidu.com")]),_._v(" 域名，如果有直接返回给客户端，如果没有执行下一步")]),_._v(" "),e("li",[_._v("本地DNS服务器向根域名服务器发送请求，查询 com 顶级域的 nameserver 地址")]),_._v(" "),e("li",[_._v("拿到com域名的IP后，再向 com nameserver 发送请求，获取 baidu 域名的nameserver 地址")]),_._v(" "),e("li",[_._v("继续请求 baidu 的 nameserver, 获取 www 域名的地址，最终得到了 "),e("code",[_._v("www.baidu.com")]),_._v(" 的IP，本地DNS服务器把这个结果缓存起来，以供下次查询快速返回")]),_._v(" "),e("li",[_._v("本地DNS服务器把把结果返回给客户端")])]),_._v(" "),e("h3",{attrs:{id:"递归服务器-与-权威域名服务器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#递归服务器-与-权威域名服务器"}},[_._v("#")]),_._v(" 递归服务器 与 权威域名服务器")]),_._v(" "),e("p",[_._v("我们在解析流程中发现两类DNS服务器，客户端直接访问的是 递归解析服务器， 它在整个解析过程中也最忙。 它的查询步骤是递归的，从根域名服务器开始，一直询问到目标域名。")]),_._v(" "),e("p",[_._v("递归解析服务器通过请求一级一级的权威域名服务器，获得下一目标的地址，直到找到目标域名的 权威域名服务器")]),_._v(" "),e("p",[_._v("简单来说： 递归解析服务器 是负责解析域名的， 权威域名服务器 是负责存储域名记录的")]),_._v(" "),e("p",[_._v("递归服务器一般由互联网服务提供商提供（电信移动联通）")]),_._v(" "),e("h3",{attrs:{id:"分级缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分级缓存"}},[_._v("#")]),_._v(" 分级缓存")]),_._v(" "),e("p",[_._v("由于整个解析过程非常复杂，所以DNS 通过缓存技术来实现服务的鲁棒性。 当递归nameserver解析过 "),e("code",[_._v("www.baidu.com")]),_._v(" 域名后，再次收到 "),e("code",[_._v("www.baidu.com")]),_._v(" 查询时，它不会再走一遍递归解析流程，而是把上一次解析结果的缓存直接返回。 并且它是分级缓存的，也就是说，当下次收到的是 "),e("code",[_._v("www.baidu.com")]),_._v(" 的查询时， 由于这台递归解析服务器已经知道 "),e("code",[_._v("baidu.com")]),_._v(" 的权威 nameserver, 所以它只需要再向 "),e("code",[_._v("baidu.com")]),_._v(" nameserver 发送一个查询www的请求就可以了。")])])}),[],!1,null,null,null);v.default=a.exports}}]);