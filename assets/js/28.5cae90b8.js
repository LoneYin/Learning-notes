(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{227:function(t,a,s){"use strict";s.r(a);var n=s(0),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器js引擎（v8）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器js引擎（v8）"}},[t._v("#")]),t._v(" 浏览器JS引擎（V8）")]),t._v(" "),s("h2",{attrs:{id:"v8的javascript执行管道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8的javascript执行管道"}},[t._v("#")]),t._v(" V8的JavaScript执行管道")]),t._v(" "),s("img",{attrs:{src:"/Learning-notes/img/v8.png"}}),t._v(" "),s("p",[t._v("V8 目前形成了由解析器、基线编译器 Ignition 和优化编译器 TurboFan 组成的 JavaScript 执行管道。")]),t._v(" "),s("p",[t._v("解析器 Parser 将 JavaScript 源代码转换成 AST，基线编译器 Ignition 将 AST 编译为字节码，当代码满足一定条件时，将被优化编译器 TurboFan 重新编译生成优化的字节码。")]),t._v(" "),s("h3",{attrs:{id:"解析器与ast"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析器与ast"}},[t._v("#")]),t._v(" 解析器与AST")]),t._v(" "),s("p",[t._v("解析代码需要时间，所以 JavaScript 引擎会尽可能避免完全解析源代码文件。另一方面，在一次用户访问中，页面中会有很多代码不会被执行到，比如，通过用户交互行为触发的动作。\n正因为如此，所有主流浏览器都实现了惰性解析（Lazy Parsing）。解析器不必为每个函数生成 AST（Abstract Syntax tree，抽象语法树），而是可以决定“预解析”（Pre-parsing）或“完全解析”它所遇到的函数。")]),t._v(" "),s("p",[t._v("预解析会检查源代码的语法并抛出语法错误，但不会解析函数中变量的作用域或生成 AST，只是生成了一个词法作用域。完全解析则将分析函数体并生成源代码对应的 AST 数据结构。相比正常解析，预解析的速度快了 2 倍。")]),t._v(" "),s("p",[t._v("生成 AST 主要经过两个阶段：分词（词法分析）和解析（语法分析）。AST旨在通过一种结构化的树形数据结构来描述源代码的具体语法组成，常用于语法检查（静态代码分析）、代码混淆、代码优化等。\n我们可以借助 AST Explorer 工具生成 JavaScript 代码的 AST。")]),t._v(" "),s("h3",{attrs:{id:"基线编译器-ignition-与字节码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基线编译器-ignition-与字节码"}},[t._v("#")]),t._v(" 基线编译器 Ignition 与字节码")]),t._v(" "),s("p",[t._v("V8 引入 JIT（Just In Time，即时编译）技术，通过 Ignition 基线编译器快速生成字节码并执行。(值得一提的是，在引入 Ignition 之前，V8 的 Full-Codegen 编译器 是跳过 AST 编译到字节码这一步的，V8 会将 AST 直接生成机器码，但是这样会使得内存负担加重，这也是Chrome之前为人诟病的一点)")]),t._v(" "),s("p",[t._v("直接生成机器码固然可以加快执行速度，但是耗费的内存空间会变大，所以V8在一开始只编译最外层代码，不能一次性编译全部的代码，而且一些只运行一次的代码会常驻，浪费了宝贵的内存资源。而引入字节码后缓存的是更紧凑的字节码，这样虽然牺牲了一点执行效率，但是既加快了启动速度，又减少了内存占用，而且跟新的优化编译器 TurboFan 完美配合，简化了架构。")]),t._v(" "),s("p",[t._v("字节码是机器码的抽象。如果字节码的设计与物理 CPU 的计算模型相同，那么将字节码编译成机器代码就会更加容易。这就是为什么解释器通常是寄存器或堆栈机器。Ignition 是一个带有累加器的寄存器。")]),t._v(" "),s("p",[t._v("和之前的基线编译器 Full-Codegen 相比，Ignition 生成的是体积更小的字节码（Full-Codegen 生成的是机器码）。字节码可以直接被优化编译器 TurboFan 用于生成机器码，避免优化编译器在优化代码时需要对 JavaScript 源代码重新进行解析。")]),t._v(" "),s("h3",{attrs:{id:"优化编译器-turbofan-与优化和去优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化编译器-turbofan-与优化和去优化"}},[t._v("#")]),t._v(" 优化编译器 TurboFan 与优化和去优化")]),t._v(" "),s("p",[t._v("编译器需要考虑的函数输入类型变化越少，生成的代码就越小、越快。")]),t._v(" "),s("p",[t._v("众所周知，JavaScript 是弱类型语言。ECMAScript 标准中有大量的多义性和类型判断，因此通过基线编译器生成的代码执行效率低下。")]),t._v(" "),s("p",[t._v("举个例子，+ 运算符的一个操作数就可能是整数、浮点数、字符串、布尔值以及其它的引用类型，更别提它们之间的各种组合（可以感受一下 ECMAScript 标准中对于 + 的定义）。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTwo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTwo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTwo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8.6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 10.8")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTwo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"world"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "hello world"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTwo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"true or "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "true or false"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 还有很多组合...")]),t._v("\n")])])]),s("p",[t._v("但这并不意味着 JavaScript 代码没有办法被优化。对于特定的程序逻辑，其接收的参数往往是类型固定的。正因为如此，V8 引入了类型反馈技术。在进行运算的时候，V8 使用类型反馈对所有参数进行动态检查。通过观察执行情况，V8 的 JIT 会将热点代码的字节码通过 TurboFan 优化为高效的机器码。")]),t._v(" "),s("p",[t._v("简单来说，对于重复执行的代码，如果多次执行都传入类型相同的参数，那么 V8 会假设之后每一次执行的参数类型也是相同的，并对代码进行优化。优化后的代码中会保留基本的类型检查。如果之后的每次执行参数类型未改变，V8 将一直执行优化过的代码。而当之后某一次执行时传入的参数类型发生变化时，TurboFan 将会“撤销”之前的优化操作，这一步称为“去优化”（Deoptimization）")]),t._v(" "),s("p",[t._v("需要注意的是，去优化的开销昂贵，在实际编写函数时要尽量避免触发去优化。")]),t._v(" "),s("h2",{attrs:{id:"垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),s("p",[t._v("V8 只能使用系统的一部分内存，所以当程序内存占用过高时，会触发 V8 的垃圾回收机制。")]),t._v(" "),s("h3",{attrs:{id:"v8-对内存的分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8-对内存的分配"}},[t._v("#")]),t._v(" V8 对内存的分配")]),t._v(" "),s("p",[t._v("V8 栈内存不用多说，当执行上下文改变的时候，栈顶的内存会先被回收。")]),t._v(" "),s("p",[t._v("V8 引擎会把内存中的 堆内存 分为两块不同的区域，一块称之为老生代（old generation），另一块是新生代（young generation）。")]),t._v(" "),s("p",[t._v("即使同处 新生代 中的对象中，它们的等级也不同，又进一步分为 初级（nursery）代 等级和 中级（intermediate）代 等级。")]),t._v(" "),s("p",[t._v("在 js 中，当一个对象第一次分配内存时，会被分配到 新生代 中的 初级（nursery）代。")]),t._v(" "),s("p",[t._v("这个对象，如果在第一轮的垃圾回收中幸存下来。那么，我们把它的等级提升到 新生代 中的 中级（intermediate）代。")]),t._v(" "),s("p",[t._v("如果再经过下一次垃圾回收，这个对象幸存下来，这时候我们就会把这个对象，从中级（intermediate）代移动到老生代。")]),t._v(" "),s("blockquote",[s("p",[t._v("V8 为什么要这么做呢？")])]),t._v(" "),s("p",[t._v("在垃圾回收中有一个重要的概念：“代际假说”（The Generational Hypothesis）。就是说，大部分的 js 对象，都是炮灰，一轮垃圾回收后，基本上都不会幸存，在内存中存在的时间很短。换句话说，从垃圾回收的角度来看，很多对象一经分配内存空间随即就变成了不可访问的，所以对象要么活得很久，要么死的很快。既然，短命的 js 对象，和命久的 js 对象有如此的差距，V8 中就把他们区分开，采用不同的垃圾回收策略。")]),t._v(" "),s("p",[t._v("当 javascript 主线程在正常的执行的时候，占用的内存空间会不断的增长。增长就会触发一个极限，触发极限的时候，垃圾回收就被触发了。对于新生代和老生代， V8 分别有两种垃圾回收器去处理。")]),t._v(" "),s("h3",{attrs:{id:"v8中两种垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8中两种垃圾回收器"}},[t._v("#")]),t._v(" V8中两种垃圾回收器")]),t._v(" "),s("p",[t._v("V8 有两个垃圾回收器，一个是主垃圾回收器(Major GC)，一个是副垃圾回收器(Minor GC)。这两个垃圾回收器，是相互独立的。")]),t._v(" "),s("p",[t._v("主垃圾回收器主要负责老生区中的垃圾回收（也会负责一部分的新生代heap），副垃圾回收器从新生代中回收垃圾。")]),t._v(" "),s("h4",{attrs:{id:"副垃圾回收器-回收步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器-回收步骤"}},[t._v("#")]),t._v(" 副垃圾回收器 回收步骤")]),t._v(" "),s("p",[t._v("副垃圾回收器采用 Scavenge 算法进行垃圾回收")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("标记")]),t._v(" "),s("p",[t._v("这一步，是为了判断这轮GC中哪些对象需要被回收。")]),t._v(" "),s("p",[t._v("如何判断呢\b？就是看这个对象能不能被找到。")]),t._v(" "),s("p",[t._v("打标首先从根部开始查找，也就是顶层的执行栈、全局的对象开始查找，然后查找对象的引用，然后是对象引用的引用，一层层递归的找。")]),t._v(" "),s("p",[t._v("如果一个对象可以被访问到，则认为这个对象是活的，打上标记表示不应该被回收；否则，就会被回收。")]),t._v(" "),s("p",[t._v("接下来，我们开始一轮垃圾回收的过程。")])]),t._v(" "),s("li",[s("p",[t._v("清除 from-space")]),t._v(" "),s("p",[t._v("将能访问到的（被标记）对象移动至 to-space (暂存区)，清空 from-space (正在使用中的内存区域)。")]),t._v(" "),s("p",[t._v("这一步也称为 撤离步骤 evacuation step。")]),t._v(" "),s("p",[t._v("撤离到 to-space 中的对象，成功的在第一轮的垃圾回收中活了下来，它们从 初级代 晋升到了 中级代。")])]),t._v(" "),s("li",[s("p",[t._v("更新引用指针")]),t._v(" "),s("p",[t._v("我们发现，js 中对象的引用指针，还是引用到了旧的 from-space 空间上，我们需要更新这些引用到 to-space 空间上。")])]),t._v(" "),s("li",[s("p",[t._v("换位")]),t._v(" "),s("p",[t._v("接下来，我们把 to-space 和 from-space 交换位置。现在 to-space 成为了下一轮的 from-space，from-space 成为了下一轮的 to-space")])]),t._v(" "),s("li",[s("p",[t._v("开启第二轮垃圾回收")]),t._v(" "),s("p",[t._v("第一轮垃圾回收之后， js 继续执行，会有一些新分配的 初级代 对象，被推入到了 from-space 空间中，安置在在\b上一轮幸存的 中级代 对象后面。第二轮垃圾回收的过程，和第一轮类似，就不赘述了。")])])]),t._v(" "),s("p",[t._v("那么为什么垃圾回收要执行两轮呢？")]),t._v(" "),s("p",[t._v("由于堆内存是连续分配的，一轮清除后零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做内存碎片。但是通过换位的操作，就可以解决内存碎片的问题，方便后续连续空间的分配")]),t._v(" "),s("p",[t._v("现今，V8 在新生代垃圾回收中使用并发清理。")]),t._v(" "),s("h4",{attrs:{id:"副垃圾回收器小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器小结"}},[t._v("#")]),t._v(" 副垃圾回收器小结")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("因为代际假说的理论，只有小部分的 js 对象是会幸存下来的，所以在副垃圾回收器中，只会撤离一小部分的对象，拷贝到to-space的空间中，其他大部分对象都统统销毁。")])]),t._v(" "),s("li",[s("p",[t._v("from-space 和 to-space 只有一个在用，空间开销很大，典型的用空间换时间。")])])]),t._v(" "),s("h4",{attrs:{id:"主垃圾回收器-回收步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器-回收步骤"}},[t._v("#")]),t._v(" 主垃圾回收器  回收步骤")]),t._v(" "),s("p",[t._v("主垃圾回收器采用 Mark-Sweep & Mark-Compact 算法")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("标记 - 清扫 Mark-Sweep")]),t._v(" "),s("p",[t._v("先是标记过程阶段，标记阶段就是从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在这个遍历过程中，能到达的元素称为活动对象,没有到达的元素就可以判断为垃圾数据。")]),t._v(" "),s("p",[t._v("然后在遍历过程中标记，标记完成后就进行清除过程。")]),t._v(" "),s("p",[t._v("它和副垃圾回收器的垃圾清除过程完全不同，这个的清除过程是删除标记数据。")])]),t._v(" "),s("li",[s("p",[t._v("标记 - 整理 Mark-Compact")]),t._v(" "),s("p",[t._v("Mark-Sweep 算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是需要 Mark-Compact 算法对不连续的内存空间进行压缩。")]),t._v(" "),s("p",[t._v("Mark-Compact 的标记过程仍然与 Mark-Sweep 算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块。")])])]),t._v(" "),s("h4",{attrs:{id:"空闲时间垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#空闲时间垃圾回收"}},[t._v("#")]),t._v(" 空闲时间垃圾回收")]),t._v(" "),s("p",[t._v("对于 JavaScript 程序员来说，我们是没有办法直接操作垃圾回收器的。")]),t._v(" "),s("p",[t._v("为了解决这个问题， V8 提出了空闲时间的概念。我们的页面跑在浏览器内，浏览器以每秒60帧的速度去执行一些动画，浏览器大约有16.6毫秒的时间去渲染动画的每一帧。")]),t._v(" "),s("p",[t._v("如果这些渲染的工作，提前完成了，那么浏览器在下一帧之前的空闲时间去触发垃圾回收器。")])])}),[],!1,null,null,null);a.default=r.exports}}]);