# 浏览器运行机制

## 进程

浏览器中的主要进程有
- 主进程（Browser Process)
  
  负责浏览器界面的显示与交互。各个页面的管理，创建和销毁其他进程。网络的资源管理、下载等

  主进程中有几个重要的线程
  - UI thread: 控制浏览器上的按钮及输入框

  - network thread: 处理网络请求，从网上获取数据

  - storage thread: 控制文件等的访问

- 第三方插件进程 (Plugin Process)

  每种类型的插件对应一个进程，仅当使用该插件时才创建

- GPU进程 (GPU Process)

  最多只有一个，用于 3D 绘制等

- 渲染进程 (Renderer Process)
  
  称为浏览器渲染进程或浏览器内核，内部是多线程的。主要负责页面渲染，脚本执行，事件处理等

## 渲染进程

渲染进程中的线程有
- GUI渲染线程
- JS引擎线程
- 事件触发线程
- 定时器触发线程
- 异步HTTP请求线程

### GUI 渲染线程

- 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
  
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

- 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行

### JS 引擎线程

- Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序（例如 V8 引擎）
  
- JS 引擎线程负责解析 Javascript 脚本，运行代码
  
- JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
  
- 注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞

### 事件触发线程

- 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
  
- 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
  
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
  
- 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

### 定时器触发线程

- setInterval 与 setTimeout 所在线程
  
- 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确）
  
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
  
- 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms

### 异步 HTTP 请求线程

- 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。

- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

## 渲染进程是如何工作的

渲染进程包括：
- 主线程 (Main Thread)
- 工作线程 (Worker Thread)
- 排版线程 (Compositor Thread)
- 光栅线程 (Raster Thread)
  
### 渲染流程
1. 构建DOM树
   
    浏览器主进程将 html 传给渲染进程，渲染进程会解析文本字符串为树形结构的 DOM 树。一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候。渲染 html 为 DOM 的方法由 HTML Standard 定义。（浏览器主进程同时开始加载次级资源如js，css，`<img>，<link>`，浏览器主进程可以在构建DOM的过程中去请求他们）
  
2. 构建渲染树
   
    CSS文件加载完毕，浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树。

3. 布局（Layout)

    浏览器根据渲染树所体现的节点、各个节点的CSS定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流（Reflow）。

4. 绘制（Paint）
    
    遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘（Repaint）。实际上，绘制过程是在多个层上完成的，这些层我们称为渲染层（RenderLayer）。

5. 渲染层合成（Composite）

    多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。


### 什么是渲染层合成

在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示（想象一下ps中的合并图层，此处是将渲染层合并），生成一个GraphicsLayer，然而有特殊的渲染层（即合成层 CompositingLayer）会单独生成一个GraphicsLayer。

这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。

对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

### 浏览器的渲染原理

几个概念： 

- 渲染层（RenderLayers)
    
    这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。比如有明确的position属性，或者opacity < 1，或者设置了filter，有transform属性且值不为none，或者overflow不为visible，有对opacity、transform、fliter应用动画等等（只要出现层叠关系，就会创建新的渲染层）

- 图形层（GraphicsLayer)

    GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。

    所以 GraphicsLayer 是一个重要的渲染载体和工具，但它并不直接处理渲染层，而是处理合成层。

- 合成层（CompositingLayer）

    满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。

#### 那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：

- 3D transforms：translate3d、translateZ 等

- video、canvas、iframe 等元素

- 通过 Element.animate() 实现的 opacity 动画转换

- 通过 СSS 动画实现的 opacity 动画转换

- position: fixed

- 具有 will-change 属性

- 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition

### 隐式合成

- 两个 absolute 定位的 div 在屏幕上交叠了，根据 z-index 的关系，其中一个 div 就会”盖在“了另外一个上边。

    <img src="/img/explore/zindex_1.jpg" />

- 这个时候，如果处于下方的 div 被加上了 CSS 属性：transform: translateZ(0)，就会被浏览器提升为合成层。提升后的合成层位于 Document 上方，假如没有隐式合成，原本应该处于上方的 div 就依然还是跟 Document 共用一个 GraphicsLayer，层级反而降了，就出现了元素交叠关系错乱的问题。

    <img src="/img/explore/zindex_2.jpg.jpg" />

- 所以为了纠正错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。

    <img src="/img/explore/zindex_3.jpg">

