<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一些JS面试题整理 | 学习笔记</title>
    <meta name="description" content="构建自己的前端知识体系">
    
    
    <link rel="preload" href="/Learning-notes/assets/css/0.styles.20926f7d.css" as="style"><link rel="preload" href="/Learning-notes/assets/js/app.d658b911.js" as="script"><link rel="preload" href="/Learning-notes/assets/js/2.ddf9653e.js" as="script"><link rel="preload" href="/Learning-notes/assets/js/44.e8a08681.js" as="script"><link rel="prefetch" href="/Learning-notes/assets/js/10.c3a0c23e.js"><link rel="prefetch" href="/Learning-notes/assets/js/11.e1bb4b5e.js"><link rel="prefetch" href="/Learning-notes/assets/js/12.e83047c4.js"><link rel="prefetch" href="/Learning-notes/assets/js/13.5a89091d.js"><link rel="prefetch" href="/Learning-notes/assets/js/14.f754104c.js"><link rel="prefetch" href="/Learning-notes/assets/js/15.e86adc7e.js"><link rel="prefetch" href="/Learning-notes/assets/js/16.be0a4e09.js"><link rel="prefetch" href="/Learning-notes/assets/js/17.5b248867.js"><link rel="prefetch" href="/Learning-notes/assets/js/18.2b9b8a55.js"><link rel="prefetch" href="/Learning-notes/assets/js/19.085577f7.js"><link rel="prefetch" href="/Learning-notes/assets/js/20.a1f504d3.js"><link rel="prefetch" href="/Learning-notes/assets/js/21.c63eeff7.js"><link rel="prefetch" href="/Learning-notes/assets/js/22.7f6c815e.js"><link rel="prefetch" href="/Learning-notes/assets/js/23.28dc79e8.js"><link rel="prefetch" href="/Learning-notes/assets/js/24.fd6038b1.js"><link rel="prefetch" href="/Learning-notes/assets/js/25.65f35670.js"><link rel="prefetch" href="/Learning-notes/assets/js/26.3f895703.js"><link rel="prefetch" href="/Learning-notes/assets/js/27.648313b4.js"><link rel="prefetch" href="/Learning-notes/assets/js/28.5cae90b8.js"><link rel="prefetch" href="/Learning-notes/assets/js/29.9b1b8f04.js"><link rel="prefetch" href="/Learning-notes/assets/js/3.9113ff3d.js"><link rel="prefetch" href="/Learning-notes/assets/js/30.94410a61.js"><link rel="prefetch" href="/Learning-notes/assets/js/31.7043d084.js"><link rel="prefetch" href="/Learning-notes/assets/js/32.ee516927.js"><link rel="prefetch" href="/Learning-notes/assets/js/33.94246ef4.js"><link rel="prefetch" href="/Learning-notes/assets/js/34.6926d321.js"><link rel="prefetch" href="/Learning-notes/assets/js/35.38cc7b7c.js"><link rel="prefetch" href="/Learning-notes/assets/js/36.552bfea3.js"><link rel="prefetch" href="/Learning-notes/assets/js/37.a3640cca.js"><link rel="prefetch" href="/Learning-notes/assets/js/38.f20ad69f.js"><link rel="prefetch" href="/Learning-notes/assets/js/39.0efc5378.js"><link rel="prefetch" href="/Learning-notes/assets/js/4.554dccb8.js"><link rel="prefetch" href="/Learning-notes/assets/js/40.f8dca0d5.js"><link rel="prefetch" href="/Learning-notes/assets/js/41.0689f648.js"><link rel="prefetch" href="/Learning-notes/assets/js/42.e17a356b.js"><link rel="prefetch" href="/Learning-notes/assets/js/43.241cdf11.js"><link rel="prefetch" href="/Learning-notes/assets/js/45.0b1691fa.js"><link rel="prefetch" href="/Learning-notes/assets/js/5.7e2a17f1.js"><link rel="prefetch" href="/Learning-notes/assets/js/6.ebe2ab56.js"><link rel="prefetch" href="/Learning-notes/assets/js/7.0440d0cc.js"><link rel="prefetch" href="/Learning-notes/assets/js/8.2826deb1.js"><link rel="prefetch" href="/Learning-notes/assets/js/9.a90915b9.js">
    <link rel="stylesheet" href="/Learning-notes/assets/css/0.styles.20926f7d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Learning-notes/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Learning-notes/notes/" class="nav-link router-link-active">前端笔记</a></div><div class="nav-item"><a href="/Learning-notes/essays/" class="nav-link">个人随笔</a></div><div class="nav-item"><a href="https://github.com/LoneYin/Learning-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Learning-notes/notes/" class="nav-link router-link-active">前端笔记</a></div><div class="nav-item"><a href="/Learning-notes/essays/" class="nav-link">个人随笔</a></div><div class="nav-item"><a href="https://github.com/LoneYin/Learning-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Learning-notes/notes/browser/浏览器的进程与线程.html" class="sidebar-link">浏览器的进程与线程</a></li><li><a href="/Learning-notes/notes/browser/浏览器的渲染原理.html" class="sidebar-link">浏览器的渲染原理</a></li><li><a href="/Learning-notes/notes/browser/浏览器JS引擎.html" class="sidebar-link">浏览器JS引擎（V8）</a></li><li><a href="/Learning-notes/notes/browser/浏览器EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/Learning-notes/notes/browser/浏览器缓存策略.html" class="sidebar-link">浏览器缓存策略</a></li><li><a href="/Learning-notes/notes/browser/跨域与页面通信.html" class="sidebar-link">跨域与页面通信</a></li><li><a href="/Learning-notes/notes/browser/浏览器DOM事件与事件监听.html" class="sidebar-link">浏览器 DOM 事件与事件监听</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Learning-notes/notes/network/TCP与DNS.html" class="sidebar-link">TCP协议与DNS协议</a></li><li><a href="/Learning-notes/notes/network/HTTP协议.html" class="sidebar-link">HTTP/HTTPS/HTTP2</a></li><li><a href="/Learning-notes/notes/network/GET和POST请求的区别.html" class="sidebar-link">GET请求和POST请求的区别</a></li><li><a href="/Learning-notes/notes/network/Web安全.html" class="sidebar-link">Web安全 —— XSS 与 CSRF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Learning-notes/notes/advanced/JS执行上下文栈.html" class="sidebar-link">JS执行上下文栈</a></li><li><a href="/Learning-notes/notes/advanced/另一个角度理解this.html" class="sidebar-link">从另一个角度理解this的隐式绑定</a></li><li><a href="/Learning-notes/notes/advanced/闭包.html" class="sidebar-link">作用域与闭包</a></li><li><a href="/Learning-notes/notes/advanced/原型链与继承.html" class="sidebar-link">原型链与继承</a></li><li><a href="/Learning-notes/notes/advanced/new运算符.html" class="sidebar-link">new运算符到底做了什么</a></li><li><a href="/Learning-notes/notes/advanced/节流和防抖.html" class="sidebar-link">函数的节流和防抖</a></li><li><a href="/Learning-notes/notes/advanced/函数柯里化.html" class="sidebar-link">函数柯里化和偏函数</a></li><li><a href="/Learning-notes/notes/advanced/深拷贝.html" class="sidebar-link">实现一个深拷贝</a></li><li><a href="/Learning-notes/notes/advanced/bind和call和apply.html" class="sidebar-link">手写 bind/call/apply</a></li><li><a href="/Learning-notes/notes/advanced/Iterator和Generator.html" class="sidebar-link">Iterator 和 Generator</a></li><li><a href="/Learning-notes/notes/advanced/Promise.html" class="sidebar-link">Promise的链式调用原理</a></li><li><a href="/Learning-notes/notes/advanced/单例模式.html" class="sidebar-link">单例设计模式的应用</a></li><li><a href="/Learning-notes/notes/advanced/观察者模式.html" class="sidebar-link">观察者模式的简单实现</a></li><li><a href="/Learning-notes/notes/advanced/使用setTimeout模拟setInterval.html" class="sidebar-link">用 setTimeout 实现 setInterval</a></li><li><a href="/Learning-notes/notes/advanced/常见算法.html" class="sidebar-link">常见算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>其他知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Learning-notes/notes/others/模块加载机制.html" class="sidebar-link">模块加载机制</a></li><li><a href="/Learning-notes/notes/others/前端性能优化.html" class="sidebar-link">前端性能优化</a></li><li><a href="/Learning-notes/notes/others/面试题整理.html" class="active sidebar-link">一些JS面试题整理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q1：输出以下代码的执行结果并解释为什么" class="sidebar-link">Q1：输出以下代码的执行结果并解释为什么</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q2：数组扁平化" class="sidebar-link">Q2：数组扁平化</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q3：-1-2-3-map-parseint-返回结果" class="sidebar-link">Q3：['1', '2', '3'].map(parseInt) 返回结果</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q4：" class="sidebar-link">Q4：[] == ![]</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q5-react中setstate在什么情况下是同步的？" class="sidebar-link">Q5: React中setState在什么情况下是同步的？</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q6-function-prototype-function-prototype" class="sidebar-link">Q6: Function[[prototype]] === Function.prototype?</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q7-为什么react的事件handler需要手动绑定this" class="sidebar-link">Q7: 为什么React的事件handler需要手动绑定this?</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q8-js函数的参数是如何传递的？" class="sidebar-link">Q8: js函数的参数是如何传递的？</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q9-object-is-判断原理" class="sidebar-link">Q9: Object.is 判断原理</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#_0-和-0" class="sidebar-link">+0 和 -0</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q10：for-in-和-for-of-的比较" class="sidebar-link">Q10：for...in 和 for...of 的比较</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q11：什么是bfc" class="sidebar-link">Q11：什么是BFC ?</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q12-谈谈-react-新的生命周期" class="sidebar-link">Q12: 谈谈 React 新的生命周期</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q13-let-var-的区别" class="sidebar-link">Q13: let var 的区别</a></li><li class="sidebar-sub-header"><a href="/Learning-notes/notes/others/面试题整理.html#q14-箭头函数的特性" class="sidebar-link">Q14: 箭头函数的特性</a></li></ul></li><li><a href="/Learning-notes/notes/others/最后梳理一遍输入URL到页面渲染的流程.html" class="sidebar-link">最后梳理一遍从输入URL到页面渲染的流程</a></li><li><a href="/Learning-notes/notes/others/Webpack知识点整理.html" class="sidebar-link">Webpack 知识点整理</a></li><li><a href="/Learning-notes/notes/others/Vue与React的区别.html" class="sidebar-link">Vue与React的区别</a></li><li><a href="/Learning-notes/notes/others/Vue源码阅读知识点整理.html" class="sidebar-link">Vue 源码阅读知识点整理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一些js面试题整理"><a href="#一些js面试题整理" class="header-anchor">#</a> 一些JS面试题整理</h1> <h2 id="q1：输出以下代码的执行结果并解释为什么"><a href="#q1：输出以下代码的执行结果并解释为什么" class="header-anchor">#</a> Q1：输出以下代码的执行结果并解释为什么</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span>

a<span class="token punctuation">.</span>x <span class="token comment">// --&gt; undefined</span>
b<span class="token punctuation">.</span>x <span class="token comment">// --&gt; {n: 2}</span>
</code></pre></div><h3 id="解析："><a href="#解析：" class="header-anchor">#</a> 解析：</h3> <p><strong>运算符优先级和连续赋值带来的坑</strong></p> <p>首先，<code>a</code>和<code>b</code>同时引用了<code>{n:2}</code>对象，接着执行到<code>a.x = a = {n：2}</code>语句，尽管赋值是从右到左的没错，但是<code>.</code>的优先级比<code>=</code>要高，所以这里首先执行<code>a.x</code>，相当于为<code>a</code>（或者<code>b</code>）所指向的<code>{n:1}</code>对象新增了一个属性x，即此时对象将变为<code>{n:1;x:undefined}</code>。</p> <p>之后按正常情况，从右到左进行赋值，此时执行<code>a ={n:2}</code>的时候，<code>a</code>的引用改变，指向了新对象<code>{n：2}</code>,而<code>b</code>依然指向的是旧对象。之后执行<code>a.x = {n：2}</code>的时候，并不会重新解析一遍<code>a</code>，而是沿用最初解析<code>a.x</code>时候的<code>a</code>，也即旧对象，故此时旧对象的<code>x</code>的值为<code>{n：2}</code>，旧对象为 <code>{n:1;x:{n：2}}</code>，它被<code>b</code>引用着。</p> <p>后面输出<code>a.x</code>的时候，又要解析<code>a</code>了，此时的<code>a</code>是指向新对象的<code>a</code>，而这个新对象是没有<code>x</code>属性的，故访问时输出<code>undefined</code>；而访问<code>b.x</code>的时候，将输出旧对象的<code>x</code>的值，即<code>{n:2}</code>。</p> <h2 id="q2：数组扁平化"><a href="#q2：数组扁平化" class="header-anchor">#</a> Q2：数组扁平化</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// [[1,2,2],[3, 4, 5, 5],[6, 7, 8, 9,[11,12,[12,13,[14]]]],10]  ------&gt;   [1,2,2,3,4,5,5,6,7,8,9,11,12,12,13,14,10]</span>

<span class="token comment">// 递归法  可使用reduce map for循环等实现</span>
<span class="token comment">// reduce</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// map</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// for</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span class="token comment">// 转字符串法 不过只适用于纯数字数组</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="q3：-1-2-3-map-parseint-返回结果"><a href="#q3：-1-2-3-map-parseint-返回结果" class="header-anchor">#</a> Q3：['1', '2', '3'].map(parseInt) 返回结果</h2> <h3 id="arrray-map"><a href="#arrray-map" class="header-anchor">#</a> Arrray.map</h3> <p><code>Array.map</code>方法会遍历原数组中的每个元素并执行<code>callback</code>，返回一个新的数组</p> <ul><li><code>callback</code>的第一个参数是<code>currentValue</code>，也就是原数组中正在处理的当前元素</li> <li><code>callback</code>的第二个参数是<code>index</code>，是原数组中正在处理的当前元素的索引</li></ul> <h3 id="parseint"><a href="#parseint" class="header-anchor">#</a> parseInt</h3> <p><code>parseInt</code>方法解析一个字符串参数，并返回一个指定基数（进制）的整数</p> <ul><li><code>parseInt</code>的第一个参数是<code>string</code>，也就是要被解析的字符串的值</li> <li><code>parseInt</code>得第二个参数是<code>radix</code>，一个介于2和36之间的整数，默认为10，代表解析字符串的基数（进制数）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
</code></pre></div><p>等同于</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>即返回值分别为</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</span>
</code></pre></div><p>所以</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
<span class="token comment">// 1, NaN, NaN</span>
</code></pre></div><h2 id="q4："><a href="#q4：" class="header-anchor">#</a> Q4：[] == ![]</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// true</span>
</code></pre></div><h3 id="解析：-2"><a href="#解析：-2" class="header-anchor">#</a> 解析：</h3> <p><code>==</code> 运算符，<code>javascript</code>语言灵活性的代表但也是最臭名昭著的黑魔法之一，比较运算之中发生的隐式类型转化不知坑了多少JSer。</p> <p>我们先来列举一下<code>==</code>（相等运算符）的运算规则</p> <ul><li>如果两个值类型相同，进行 <code>====</code> （严格相等运算符） 比较</li> <li>如果两个值类型不同，它们可能是相等的，此时根据下列规则进行类型转换后比较:
<ol><li>如果一个值为<code>null</code>，另一个是<code>undefined</code>，那么<strong>相等</strong></li> <li>如果一个值是<code>String</code>，另一个是<code>Number</code>，在比较之前要先将<code>String</code>转换为<code>Number</code>，即调用<code>Number()</code>方法</li> <li>如果一个值是<code>Boolean</code>，则先将这个<code>Boolean</code>转换为数值后再进行比较，即调用<code>Number()</code>方法</li> <li>如果一个值是<code>Object</code>，另一个是<code>String</code>或<code>Number</code>，则先将对象转换为基本数据类型再比较，即调用<code>javascript</code>内置类的<code>valueOf</code>或<code>toString</code>方法，<code>valueOf</code>会先于<code>toString</code>，例外的是<code>Date</code>对象，会直接用<code>toString</code>转换</li></ol></li></ul> <p>接下来我们分析一下<code>[] == ![]</code>为什么返回<code>true</code></p> <ol><li>首先运算符右边的<code>![]</code>会先进行运算，得到<code>false</code>，即<code>[] == false</code></li> <li>当等式两边有<code>Boolean</code>值得时候会先对其进行类型转换，即<code>Number(false) = 0</code>，等式两边变为<code>[] == 0</code></li> <li>当等式两边一个值为<code>Object</code>另一个为<code>Number</code>时，将<code>Object</code>进行类型转换，即<code>[].valueOf()</code>，发现返回的结果<code>[]</code>仍是<code>Object</code>，所以再调用<code>[].toString()</code>得到<code>''</code>，<code>Number('')</code>得到<code>0</code></li> <li><code>0 == 0</code> 成立， 返回<code>true</code></li></ol> <h2 id="q5-react中setstate在什么情况下是同步的？"><a href="#q5-react中setstate在什么情况下是同步的？" class="header-anchor">#</a> Q5: React中setState在什么情况下是同步的？</h2> <p>在 React 中，如果是在 React 引发的事件处理方法（比如通过 onClick 引发的事件处理）或在生命周期中调用 setState 不会同步更新 this.state 。除此之外的 setState 调用会同步执行this.state。所谓<strong>除此之外</strong>，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。</p> <blockquote><p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。  —— <a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener noreferrer">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <blockquote><p>setState 的<strong>异步</strong>并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和生命周期钩子函数的调用顺序在更新之前（当前组件会添加_pendingStateQueue属性并被放入dirtyComponents中等待稍后更新）。导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</p></blockquote> <blockquote><p>setState 的批量更新优化也是建立在<strong>异步</strong>（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在<strong>异步</strong>中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p></blockquote> <p>关于setState的具体内容详见大佬的文章<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="noopener noreferrer">《你真的理解setState吗？》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="q6-function-prototype-function-prototype"><a href="#q6-function-prototype-function-prototype" class="header-anchor">#</a> Q6: Function[[prototype]] === Function.prototype?</h2> <p>是对的  因为 Function 也是一个函数，它的__proto__指向 Function 构造函数的原型，很扯</p> <p>应该是现有 Function.prototype 然后有的 function Function()</p> <h2 id="q7-为什么react的事件handler需要手动绑定this"><a href="#q7-为什么react的事件handler需要手动绑定this" class="header-anchor">#</a> Q7: 为什么React的事件handler需要手动绑定this?</h2> <p>相对于其他框架来说，react使用了合成事件（SyntheticEvent）来标准化浏览器的事件。</p> <p>合成事件是一种顶层代理机制，这种代理机制作用的结果是：</p> <blockquote><p>事件依然在真实的dom节点上触发，之后会冒泡一路到document的节点，然后开始分发document节点收集到的事件，这个时候react从事件触发的组件实例开始， 遍历虚拟dom树，从树上取下我们绑定的事件，收集起来，然后执行。</p></blockquote> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
   <span class="token function-variable function">fatherHandler</span> <span class="token operator">=</span>  <span class="token keyword">function</span> <span class="token function">father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span><span class="token punctuation">}</span>
   <span class="token function-variable function">childHander</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/*...*/</span><span class="token punctuation">}</span>

   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span>
       <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fatherHandler<span class="token punctuation">}</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>span onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>childHander<span class="token punctuation">}</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当事件触发以后react会把上面的事件处理函数放到一个数组里是这样的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>father<span class="token punctuation">,</span> child<span class="token punctuation">]</span>
</code></pre></div><p>最后，react只要遍历执行这个数组，就能执行所有需要执行的事件处理函数。哈哈，想必眼尖的同学已经看出问题了，之前我们对函数进行了临时保存(简单粗暴的把事件处理函数赋值给了onClick属性)，这个时候执行的话，this自然就丢失了。有的同学也说了这其实不是react的锅，是js本身的问题。但是如果react保存顺便保存一下实例，还是可以做到，不需要你绑定this的，但是这样对于react来说代价太大了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">{</span>instance<span class="token punctuation">,</span> father<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>instance，child<span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre></div><h2 id="q8-js函数的参数是如何传递的？"><a href="#q8-js函数的参数是如何传递的？" class="header-anchor">#</a> Q8: js函数的参数是如何传递的？</h2> <blockquote><p>ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p></blockquote> <p>参数如果是基本类型是按值传递，如果是引用类型按共享传递。共享传递是指，在传递对象的时候，传递对象的引用的副本。</p> <p><strong>注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的<code>引用的副本</code>！</strong></p> <p>也就是说，你在函数内部直接修改作为参数传进来的对象的引用，是不会影响到原对象的引用的，但是你在没有改引用的状态下更改了对象某个属性的值，原对象也会变化</p> <h2 id="q9-object-is-判断原理"><a href="#q9-object-is-判断原理" class="header-anchor">#</a> Q9: Object.is 判断原理</h2> <p>Object.is() 判断两个值是否相同。如果下列任何一项成立，则两个值相同：</p> <ul><li><p>两个值都是 undefined</p></li> <li><p>两个值都是 null</p></li> <li><p>两个值都是 true 或者都是 false</p></li> <li><p>两个值是由相同个数的字符按照相同的顺序组成的字符串</p></li> <li><p>两个值指向同一个对象</p></li> <li><p>两个值都是数字并且</p> <ul><li>都是正零 +0</li> <li>都是负零 -0</li> <li>都是 NaN</li> <li>都是除零和 NaN 外的其它同一个数字</li></ul></li></ul> <h2 id="_0-和-0"><a href="#_0-和-0" class="header-anchor">#</a> +0 和 -0</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 也就是+0</span>
<span class="token number">0</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0</span> 

<span class="token number">0</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// true</span>
<span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// true</span>

<span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>   <span class="token comment">// Infinity</span>
<span class="token number">1</span><span class="token operator">/</span><span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// -Infinity</span>
<span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span> <span class="token comment">// false</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>当然+0与-0的存在也不是完全没有用处，我们有时会用符号位存储一些信息，比较向量或速度的方向信息,如速度-0,负号代表着运动的方向，保留了负号位可以防止这些信息的丢失。</p> <h2 id="q10：for-in-和-for-of-的比较"><a href="#q10：for-in-和-for-of-的比较" class="header-anchor">#</a> Q10：for...in 和 for...of 的比较</h2> <p>for...in的缺点</p> <ul><li>数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。</li> <li>for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li> <li>某些情况下，for...in循环会以任意顺序遍历键名。</li> <li>for...in循环主要是为遍历对象而设计的，不适用于遍历数组。</li></ul> <p>for...of的优点</p> <ul><li>有着同for...in一样的简洁语法，但是没有for...in那些缺点，可以遍历数组和各种数据结构。</li> <li>提供了遍历所有数据结构的统一操作接口。</li></ul> <h2 id="q11：什么是bfc"><a href="#q11：什么是bfc" class="header-anchor">#</a> Q11：什么是BFC ?</h2> <h3 id="box"><a href="#box" class="header-anchor">#</a> Box</h3> <p>是浏览器渲染进程中的 GUI 渲染线程布局的基本单位，DOM 树 + CSSOM 树 会生成一棵 Box 树 (也就是我们所说的 Render Tree)，它表示着当前渲染文档的格式化结构（一种过渡的结构），而根据 DOM 元素的 tag 和他的 CSS display 属性，会产生下面两大类 boxes</p> <ol><li><p>block-level boxes</p> <p>属性为 block, flex, grid, table 的元素，会生成 block-level box</p></li> <li><p>inline-level boxes</p> <p>display 属性为 inline, inline-block, inline-flex, inline-grid, inline-table 的元素，会生成 inline-level box</p></li></ol> <p>这两个大类下还有许多小类比如</p> <ol><li>block box</li> <li>block container box</li> <li>inline box</li> <li>flex container box</li> <li>grid container box</li> <li>table wrapper box containing table grid box</li></ol> <h3 id="格式化上下文"><a href="#格式化上下文" class="header-anchor">#</a> 格式化上下文</h3> <p>格式化上下文 Formatting Context 是一种布局规则，它决定了一个 box 内部子元素将如何定位，以及和其他元素的关系和相互作用</p> <blockquote><p>a flex formatting context lays out boxes according to the flex layout rules, whereas a block formatting context lays out boxes according to the block-and-inline layout rules (也就是我们所说的正常流，另外两种是浮动和定位)</p></blockquote> <p>一个 box 要么创建新的格式化上下文，也么继承外部的格式化上下文</p> <p>当一个 box 建立一个独立的格式化上下文（无论该格式化上下文与它的父级是否具有相同的类型）时，它实际上会创建一个新的独立的布局环境：除了通过调整框本身的大小之外，其后代的布局是（通常）不受框外格式化上下文的规则和内容的影响，反之亦然。</p> <h3 id="bfc"><a href="#bfc" class="header-anchor">#</a> BFC</h3> <p>下列方式会为 box 内部创建块格式化上下文：</p> <ol><li>根元素</li> <li>浮动元素（元素的 float 不是 none）</li> <li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li> <li>overflow 值不为 visible 的块元素</li> <li>display 值为 flow-root 的元素</li> <li>行内块元素（元素的 display 为 inline-block）</li> <li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li> <li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li> <li>弹性元素（display为 flex 或 inline-flex 元素的直接子元素，也就是 flex-items）</li> <li>网格元素（display为 grid 或 inline-grid 元素的直接子元素，也就是 grid-items）</li></ol> <p>BFC布局规范:</p> <ol><li>内部的 box 会在垂直方向，一个接一个地放置，参照正常文档流</li> <li>属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠（外边距重叠）</li> <li>BFC 的区域不会与浮动元素重叠，计算 BFC 的高度时，浮动元素也参与计算</li> <li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素的布局，反之也如此</li></ol> <p>BFC解决的问题：</p> <ol><li>解决浮动塌陷</li> <li>解决外边距重叠</li></ol> <h2 id="q12-谈谈-react-新的生命周期"><a href="#q12-谈谈-react-新的生命周期" class="header-anchor">#</a> Q12: 谈谈 React 新的生命周期</h2> <p>在 componentWillReceiveProps(prevProps, nextProps) 中根据 props 更新 state 并不是一个最好的方案，它可能会包含一些副作用。</p> <p>getDerivedStateFromProps(props, state) 禁止访问 this.props，强制指定 props 只能和 state 进行比对，可以说是为 setState 而创建的，而那些需要 this.props 做的事则通过 componentDidUpdate 来做</p> <p>getDerivedStateFromProps 不仅在 props 变化的时候触发，而是在每次 render（ state 和 props 更新）时就会触发</p> <p>getSnapshotBeforeUpdate(prevProps, prevState) 必须和 componentDidUpdate 一起使用，必须有返回值，返回值将作为第三个参数传递给 componentDidUpdate，主要是为了方便对更新前的 DOM 做一次快照，然后在更新后进行对比再执行一些逻辑</p> <h2 id="q13-let-var-的区别"><a href="#q13-let-var-的区别" class="header-anchor">#</a> Q13: let var 的区别</h2> <h3 id="区别1：初始化-变量提升-与暂时性死区"><a href="#区别1：初始化-变量提升-与暂时性死区" class="header-anchor">#</a> 区别1：初始化(变量提升)与暂时性死区</h3> <p>当解析器将代码转换为AST的时候，变量就会在一个词法作用域下完成声明，let/const 还会检查该词法作用域下有无同名的变量，有的话则报语法错误</p> <p>当函数真正执行的时候，也就是执行上下文初始化的时候，var 声明的变量也会初始化 (分配内存 + 赋值undefined)，函数声明则会直接初始化 + 赋值，而 let 声明的变量则要到执行的那一行的时候才会初始化，如果那一行是赋值操作，则初始化+赋值同时进行，所以 let 声明的变量之所以出现暂时性死区，是因为它还未完成初始化。const 同理。</p> <h3 id="区别2：挂钩顶层对象属性"><a href="#区别2：挂钩顶层对象属性" class="header-anchor">#</a> 区别2：挂钩顶层对象属性</h3> <p>顶层对象的属性(window)与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。</p> <p>在全局环境下，var 和 function 声明的变量都会挂载到顶层对象(window)上，而 ES6 中的 let const class 则不会</p> <h3 id="区别3：块级作用域"><a href="#区别3：块级作用域" class="header-anchor">#</a> 区别3：块级作用域</h3> <p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p> <p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p> <h2 id="q14-箭头函数的特性"><a href="#q14-箭头函数的特性" class="header-anchor">#</a> Q14: 箭头函数的特性</h2> <ol><li><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。箭头函数表达式对非方法函数是最合适的，如果作为一个对象的方法则需要考虑一下 this 指向的问题</p></li> <li><p>由于箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数而不能绑定 this，他们的第一个参数会被忽略</p></li> <li><p>箭头函数没有 Arguments 对象，在大多数情况下，使用剩余参数是相较使用arguments对象的更好选择</p></li> <li><p>箭头函数不能用作构造器，和 new一起用会抛出错误（xxx is not a constructor）。因为它没办法正常的调用 call() 或 apply()，而且没有 prototype 属性</p></li> <li><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Learning-notes/notes/others/前端性能优化.html" class="prev">前端性能优化</a></span> <span class="next"><a href="/Learning-notes/notes/others/最后梳理一遍输入URL到页面渲染的流程.html">最后梳理一遍从输入URL到页面渲染的流程</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Learning-notes/assets/js/app.d658b911.js" defer></script><script src="/Learning-notes/assets/js/2.ddf9653e.js" defer></script><script src="/Learning-notes/assets/js/44.e8a08681.js" defer></script>
  </body>
</html>
