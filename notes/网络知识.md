# 网络知识

## 网络分层

- 物理层
- 数据链路层 (以太网)
- 网络层（IP）
- 传输层（TCP UDP)
- （TLS/SSL 在这里）
- 应用层（HTTP, DNS, FTP, SMTP(邮件)）

## TCP

### TCP 协议的特点

1. 面向连接
    
    面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

2. 仅支持单播传输
    
    每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。

3. 面向字节流
  
    TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。

4. 可靠传输
    
    对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

5. 提供拥塞控制
  
    当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞

6. TCP 提供全双工通信
    
    TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）

### TCP 三次握手

> 客户端：我想和你建立连接。

> 服务端：ok，我现在可以和你建立连接。

> 客户端：好的，那我们现在开始连接吧。

- 第一次握手：客户端发送一个 TCP 标志位 SYN=1，ACK=0 的数据包给服务端，并随机会产生一个 Sequence number=3233.当服务端接收到这个数据后，服务端由 SYN=1 可知客户端是想要建立连接；

- 第二次握手：服务端要对客户端的联机请求进行确认，向客户端发送应答号 ACK=1、SYN=1
  确认号 Acknowledge number=3234，此值是客户端的序列号加 1，还会产生一个随机的序列号 Sequence number=36457，这样就告诉客户端可以进行连接；

- 第三次握手：客户端收到数据后检查 Acknowledge number 是否是 3233+1 的值，以及 ACK 的值是否为 1，若为 1，host1 会发送 ACK=1、确认号码 Acknowledge number=36457，告诉服务端,你的请求连接被确认，连接可以建立。

### TCP 四次挥手

> 客户端：我准备断开连接了。

> 服务端：ok，但是我这边可能还有一些数据要传，等我传我我会通知你。

> 服务端：我传完了，可以断开连接了。

> 客户端：ok，你断开连接吧。

> 服务端：收到客户端最后一次信息后断开连接，未收到就会要求客户端重新发送关闭信息；
> 客户端：发送最后一次信息后等待 2MLS(2 倍报文最大生存时间)，没有收到服务端的重传请求就关闭自己的连接

- 第一次挥手：当传输的数据到达尾部时，客户端向服务端发送 FIN=1 标志位；可理解成，客户端向服务端说，我这边的数据传送完成了，我准备断开了连接；

- 第二次挥手：因 TCP 的连接是全双工的双向连接，关闭也是要从两边关闭；当服务端收到客户端发来的 FIN=1 的标志位后，服务端不会立刻向客户端发送 FIND=1 的请求关闭信息，
  而是先向客户端发送一个 ACK=1 的应答信息，表示：你请求关闭的请求我已经收到，但我可能还有数据没有完成传送，你再等下，等我数据传输完成了我就告诉你；

- 第三次挥手：服务端数据传输完成，向客户端发送 FIN=1，客户端收到请求关闭连接的请求后，客户端就明白服务端的数据已传输完成，现在可以断开连接了，

- 第四次挥手：客户端收到 FIND=1 后，客户端还是怕由于网络不稳定的原因，怕服务端不知道他要断开连接，于是向服务端发送 ACK=1 确认信息进行确认，
  把自己设置成 TIME_WAIT 状态并启动定时器，如果服务端没有收到 ACK，服务端 TCP 的定时器到达后，会要求客户端重新发送 ACK，当服务端收到 ACK 后，服务端就断开连接；
  当客户端等待 2MLS（2 倍报文最大生存时间）后，没有收到服务端的重传请求后，他就知道服务端已收到了 ACK，所以客户端此时才关闭自己的连接。

## DNS

DNS (Domain Name System)， 也叫网域名称系统，是互联网的一项服务。它实质上是一个 域名 和 IP 相互映射的分布式数据库，有了它，我们就可以通过域名更方便的访问互联网。

DNS服务 使用 UDP 协议发送查询请求。

### 域名级别

域名级别是网址分类的一个标准，包括顶级域名、二级域名等。一个完整的域名由二个或二个以上部分组成，各部分之间用英文的句号`.`来分隔，倒数第一个`.`的右边部分称为顶级域名（TLD，也称为一级域名，包含一个合法字符串，和一个域名后缀），顶级域名的左边部分字符串到下个`.`为止称为二级域名（SLD），二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。所有域名后面其实都有一个隐藏的`.`，代表根域名。

拿 `www.baidu.com` 来说  顶级域名com 二级域名baidu 三级域名www

### DNS解析流程

默认是先查找hosts文件，如果没有匹配到，再进行DNS解析

1. 客户端向本地DNS服务器(递归解析服务器) 发出解析 `www.baidu.com` 域名的请求
2. 本地DNS服务器查看缓存，是否有缓存过 `www.baidu.com` 域名，如果有直接返回给客户端，如果没有执行下一步
3. 本地DNS服务器向根域名服务器发送请求，查询 com 顶级域的 nameserver 地址
4. 拿到com域名的IP后，再向 com nameserver 发送请求，获取 baidu 域名的nameserver 地址
5. 继续请求 baidu 的 nameserver, 获取 www 域名的地址，最终得到了 `www.baidu.com` 的IP，本地DNS服务器把这个结果缓存起来，以供下次查询快速返回
6. 本地DNS服务器把把结果返回给客户端

### 递归服务器 与 权威域名服务器

我们在解析流程中发现两类DNS服务器，客户端直接访问的是 递归解析服务器， 它在整个解析过程中也最忙。 它的查询步骤是递归的，从根域名服务器开始，一直询问到目标域名。

递归解析服务器通过请求一级一级的权威域名服务器，获得下一目标的地址，直到找到目标域名的 权威域名服务器

简单来说： 递归解析服务器 是负责解析域名的， 权威域名服务器 是负责存储域名记录的

递归服务器一般由互联网服务提供商提供（电信移动联通）

### 分级缓存

由于整个解析过程非常复杂，所以DNS 通过缓存技术来实现服务的鲁棒性。 当递归nameserver解析过 `www.baidu.com` 域名后，再次收到 `www.baidu.com` 查询时，它不会再走一遍递归解析流程，而是把上一次解析结果的缓存直接返回。 并且它是分级缓存的，也就是说，当下次收到的是 `www.baidu.com` 的查询时， 由于这台递归解析服务器已经知道 `baidu.com` 的权威 nameserver, 所以它只需要再向 `baidu.com` nameserver 发送一个查询www的请求就可以了。

## HTTPS

现在一般使用的是 TLS（基于 RSA 非对称加密）

TLS(Transport Layer Secure 传输层安全)1.0 === SSL(Secure Socket Layer 安全套接层)3.0

### 握手流程（包含 Pre-Master Secret）

1. 浏览器给出协议版本号、一个客户端生成的随机数（Client Random），以及客户端支持的加密方法，发出安全请求。

2. web 服务器确认双方使用的加密方法，并给出数字证书（包含服务器的**公钥**）、以及一个服务器生成的随机数（Server Random）。

3. 浏览器通过预置的 CA 列表确认数字证书有效（这一步使得中间人没法造假），然后生成一个新的随机数（Pre-Master Secret），并使用数字证书中的**公钥**加密这个随机数，发给 web 服务器。

4. web 服务器使用自己的**私钥**，获取浏览器发来的随机数（即 Pre-Master Secret），非对称加密部分完结。

5. 浏览器和 web 服务器根据约定的加密方法，使用前面的三个随机数，生成对称秘钥"对话密钥"（Session Key），用来加密接下来的整个对话过程。

## HTTP2

1. **新的二进制格式**： HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。
2. **多路复用**：即连接共享，HTTP2.0 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行，HTTP1.x 则可能会因为一个请求超时而发生线头阻塞。
3. **header 压缩**：HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。
4. **服务端推送**：服务端推送能把客户端所需要许多资源随着单次请求一起发送到客户端，省去了客户端重复请求的步骤

## HTTP

### HTTP 请求报文组成

- 请求方法（GET/POST 等）
- URI
- 协议版本 (HTTP/1.1)
- 请求头
- 请求体

### 请求头字段

- **Accept**：客户端能够处理的媒体类型。如 text/html, 表示客户端让服务器返回 html 类型的数据
- **Authorization**：表示客户端的认证信息，jwt 中 token 存放于此
- **Host**： 表示访问资源所在的主机名，即 URL 中的域名部分
- **Origin**： 站点信息 如 baidu.com
- **Referer**：告知服务器请求是从哪个页面发起的 如 baidu.com/xxx
- **User-Agent**：将发起请求的浏览器和代理名称等信息发送给服务端

- **If-None-Match**: If-Match 的值与所请求资源的 ETag 值不一致时服务器才处理此请求

- **If-Modified-Since**: 用于确认客户端拥有的本地资源的时效性。 如果客户端请求的资源在 If-Modified-Since 指定的时间后发生了改变，则服务器处理该请求，失效了就返回新的

- **Range**：获取部分资源，如视频流（服务器正确处理则返回 206 状态码）

- Accept-Charset: 表示客户端支持的字符集。例如：Accept-Charset: GB2312, ISO-8859-1
  
- Accept-Encoding： 表示客户端支持的内容编码格式。如：Accept-Encoding：gzip
  
- Accept-Language：表示客户端支持的语言。如：Accept-Language: zh-cn, en
  
- If-Match: If-Match 的值与所请求资源的 ETag 值（实体标记，与资源相关联。资源变化，实体标记跟着变化）一致时，服务器才处理此请求
  
- If-Unmodified-Since：与 If-Modified-Since 相反，表示请求的资源在指定的时间之后未发生变化时，才处理请求，否则返回 412

- If-Range： If-Range 的值（ETag 值或时间）与所访问资源的 ETag 值或时间相一致时，服务器处理此请求，并返回 Range 字段中设置的指定范围的数据。如果不一致，则返回所有内容 If-Range 其实算是 If-Match 的升级版，因为它的值不匹配时，依然能够返回数据，而 If-Match 不匹配时，请求不会被处理，需要数据时需再次进行请求

- Max-Forwards：表示请求可经过的服务器的最大数目，请求每被转发一次，Max-Forwards 减 1，当 Max-Forwards 为 0

- Cookie：属于请求型报文字段，在请求时添加Cookie, 以实现HTTP的状态记录

### HTTP 响应报文组成

- 方法
- URI
- 协议版本
- 响应头
- 响应体

其中Url包括
- protocal 协议头 比如http https ftp
- host  主机域名或ip地址
- port 端口号
- path 目录路径（路由）
- query 查询参数
- hash #后的哈希值

### 响应头字段

CORS相关
- Access-Control-Allow-Headers: 如 Authorization
- Access-Control-Allow-Methods: GET, OPTIONS, HEAD, PUT, POST
- Access-Control-Allow-Origin: 如 https://baidu.com
- Access-Control-Max-Age: 1800

普通响应头

- **Content-Length**：响应体的长度

- **Content-Range**：在整个返回体中本部分的字节位置，对应Rnage

- **Content-Type**：返回内容的MIME类型，对应Accept

- **ETag**：请求变量的实体标签的当前值

- **Expires**：响应过期的日期和时间

- **Last-Modified**：请求资源的最后修改时间

- Accept-Ranges：表明服务器是否支持指定范围请求及哪种类型的分段请求

- Age：从原始服务器到代理缓存形成的估算时间（以秒计，非负）

- Allow：对某网络资源的有效的请求行为，不允许则返回405

- Content-Encoding：服务器支持的返回内容压缩编码类型

- Content-Language：响应体的语言

- Content-Location：请求资源可替代的备用的另一地址

- Content-MD5：返回资源的MD5校验值

- Location：用来重定向接收方到非请求URL的位置来完成请求或标识新的资源

- Pragma：包括实现特定的指令，它可应用到响应链上的任何接收方

- Proxy-Authenticate：它指出认证方案和可应用到代理的该URL上的参数

- refresh：应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）

- Retry-After：如果实体暂时不可取，通知客户端在指定时间之后再次尝试

- Server：告知服务端当前使用的HTTP服务器应用程序的相关信息

- Set-Cookie：属于应答型报文字段。服务器给客户端传递Cookie信息时，就是通过此字段实现的

### 通用头部字段

- **Cache-Control**：控制缓存行为（max-age/no-cache/no-store）

- **Connection**：管理持久连接，设置其值为Keep-Alive可实现长连接

- Via：追踪客户端和服务端之间的报文的传输路径，还可避免会环的发生，所以在经过代理时必须添加此字段

- Transfer-Encoding：规定了传输报文主题时使用的传输编码，如Transfer-Encoding: chunked

- Date：创建HTTP报文的日期和时间

- Pragma：Http/1.1之前的历史遗留字段，仅作为HTTP/1.0向后兼容而定义，虽然是通用字段，当通常被使用在客户单的请求中，如Pragma: no-cache, 表示客户端在请求过程中不循序服务端返回缓存的数据

- Upgrade: 用于检查HTTP协议或其他协议是否有可使用的更高版本

- Warning：Http/1.1的报文字段，从Http/1.0的AfterRetry演变而来，用来告知用户一些与缓存相关的警告信息
  
### HTTP状态码

#### 2XX 成功

* 200 OK，表示从客户端发来的请求在服务器端被正确处理
* 204 No content，表示请求成功，但响应报文不含实体的主体部分
* 206 Partial Content，进行范围请求（请求实体部分内容成功）

#### 3XX 重定向

* 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
* 302 found，临时性重定向，表示资源临时被分配了新的 URL
* 303 see other，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源
* 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况(一般是命中了缓存)

#### 4XX 客户端错误

* 400 bad request，请求报文存在语法错误
* 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
* 403 forbidden，表示对请求资源的访问被服务器拒绝
* 404 not found，表示在服务器上没有找到请求的资源

#### 5XX 服务器错误

* 500 internal sever error，表示服务器端在执行请求时发生了错误
* 502 bad gateway，错误网关，一般是服务器网络错误
* 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求


## GET请求和POST请求的区别

### 二者在本质上没有区别，只是语义上并不相同

GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 二者的区别都是我们约定出来的（浏览器和服务器共同遵循的约定）。

### 报文格式上的区别

报文格式上，不带参数时，最大区别就是第一行方法名不同，不带参数时他们的区别就仅仅是报文的前几个字符不同而已。

>POST方法请求报文第一行是这样的 POST /uri HTTP/1.1 \r\n

>GET方法请求报文第一行是这样的 GET /uri HTTP/1.1 \r\n

带参数时报文的区别呢？ 在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中

### 请求时的区别

GET和POST还有一个重大区别，简单的说：

GET产生一个TCP数据包，POST产生两个TCP数据包（并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次）

长的说：

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据），而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

### 应用中的区别

- GET 请求可被缓存， POST 请求不会被缓存
- GET 请求保留在浏览器历史记录中， POST 请求不会保留在浏览器历史记录中
- GET 请求可被收藏为书签， POST 不能被收藏为书签
- GET 请求不应在处理敏感数据时使用，因为会明文展示给用户
- GET 请求有长度限制，POST 请求对数据长度没有要求
- GET 请求只应当用于取回数据
